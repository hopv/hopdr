\documentclass[runningheads]{llncs}
\usepackage{amsmath, amssymb}
\usepackage{mathtools}
\usepackage{braket}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{mathpartir}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{graphicx}

\newcommand \nhz{\(\nu\text{HFL}_\mathbb{Z}\)}
\newcommand \hflz {\(\text{HFL}_\mathbb{Z}\)}

\newcommand\COL{\mathbin{:}}

% nhz syntax
\newcommand \true {\textbf{tt}}
\newcommand \false {\textbf{ff}}
\newcommand \predicate {\textbf{p}}
\newcommand \arith {\textbf{a}}
\newcommand \operator {\mathbin{\textbf{op}}}
\newcommand \term {M}
\newcommand \atom {A}
\newcommand \goal {G}
\newcommand \definite {D}

% nu HFLz semantics
\newcommand {\val}[1]{[\![#1]\!]}
\newcommand {\vwt}[3][]{\val{\wt{#2}{#3}}(\alpha\ifthenelse{\isempty{#1}}{}{[#1]})}
\newcommand {\wta}[3]{\Gamma, #1 \vdash_H #2 : #3}
\newcommand {\vwta}[3]{\val{\wta{#1}{#2}{#3}}(\alpha)}

\newcommand {\valfun}{\alpha}
\newcommand {\domain}[1]{\mathcal{D}_{#1}}
\newcommand {\order}[1]{\sqsubseteq_{#1}}
\newcommand {\join}[1]{\sqcap_#1}
\newcommand {\meet}[1]{\sqcup_#1}
\newcommand \gfp {\textbf{gfp}}


% simple type
\newcommand \stypeint {\textbf{Int}}
\newcommand \stypebool {\bullet}
\newcommand \srtype {\rho} % simple result type
\newcommand \satype {\eta} % simple argument type
\newcommand \senv {\Gamma}
\newcommand \wt[3][]{\ifthenelse{\isempty{#1}}{\senv}{\senv, #1} \vdash_H #2: #3}

% refinement type syntax
\newcommand \constraint {\theta}
\newcommand \refty {\tau}
\newcommand \typeint[1]{{#1} : \stypeint}
\newcommand \typebool[1]{\stypebool \langle #1 \rangle}

% refinement type judgement
\newcommand \refines[2]{#1:: #2}
\newcommand \tenv {\Gamma}
\newcommand \wf[2][]{\tenv \vdash \refines{#1}{#2}}

% refinement type semantics
\newcommand {\semt}[1]{(\!|#1|\!)}
\newcommand {\mjudge}[2]{\tenv \models #1: #2}
\newcommand {\semsbt}[3][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation #3}
\newcommand {\wsemsbt}[4][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation_{#4} #3}
\newcommand {\srt}[2]{\semt{\wf{#1}{#2}}(\alpha)}
\newcommand {\srtg}[3][]{\semt{\wf{#2}{#3}}(\alpha[#1])}
\newcommand {\vc}[1]{[\!|#1|\!]}
\newcommand {\vtenv}[2][]{\val{#2}({\ifthenelse{\isempty{#1}}{\valfun}{#1}})}


\begin{document}

\section{Higher-order PDR}

The target problem is \nhz{} validity checking.
For the syntax of the target language, we adopt the following HES-like language,
which is equivalent to \nhz{} since we can translate them mutually.

\subsection{Target Language}

\begin{align*}
    \goal &\quad ::= \quad
          G \land G
          \mid G \lor G
          \mid \forall x. G
          \mid \atom
          \mid \constraint
         \\
    \definite &\quad ::= \quad X x_1 \cdots x_n =_\nu G
          \\
    \atom &\quad ::= \quad X\ M_1\ \cdots\ M_k\\
    \constraint &\quad ::= \quad \cdots
\end{align*}

We consider every definite formulas and goal formulas are simply typed.

Then \nhz{} validity checking is that given definite formulas
\( X_1 \bar{x_1} = \psi_1, \cdots X_n \bar{x_n} =  \psi_n \)
and a goal formula \( \psi \),
we check the validity of \( \psi \).

\subsection{refinement type}

\subsubsection{Syntax}

\begin{align*}
  &\textit{arithmetic expressions} &
  \arith &::=
  n
  \mid
  x
  \mid
  \operator(\arith_1, \cdots, \arith_n)
  \\
  &\textit{constraint formulas}&
  \constraint &::=
  \true
  \mid \false
  \mid \predicate(\arith_1, \cdots, \arith_n)
  \mid \constraint_1 \land \constraint_2
  \mid \constraint_1 \lor \constraint_2
  \\
  &\textit{refinement types}&
  \refty &::=
  \typebool{\theta}
  \mid \typeint{x} \rightarrow \refty
  \mid \refty_1 \rightarrow \refty_2
  \mid \refty_1 \land \refty_2
\end{align*}

\subsubsection{Semantics}

\begin{align*}
    \srt{\constraint}{\stypebool} &= \{\val{\tenv \vdash_c \constraint}(\alpha), \top \}\\
    \srt{\typeint{x} \rightarrow \refty}{\stypeint \rightarrow \srtype} &=
      \{f \in \domain{\stypeint \rightarrow \srtype} \mid \forall v \in \domain{\stypeint}. \\
          &\quad \quad f(v) \in \semt{\tenv, x \vdash \refty:: \srtype}(\alpha[x \mapsto v])\\
    \srt{\refty_1 \rightarrow \refty_2}{\srtype_1 \rightarrow \srtype_2} &= \{f \in \domain{\srtype_1 \rightarrow \srtype_2} \mid \forall v \in
        \srt{\refty_1}{\srtype_1}. \\
          &\quad \quad \quad f(v) \in \srt{\refty_2}{\srtype_2}\}
\end{align*}

\subsection{type system}

The same one as APLAS20

\subsection{algorithm}

During the execution of the following algorithm,
we hold two states: candidates and current environments.
To specify them, we use notation \( M \mid \mid S \), where
\( M \) specify candidates and \( S \) is a current environment.

In an environment, there is two variables:
a current expansion number \( N \)
and a sequence of type environment \( \{\Gamma_i\}_{i \in \{1, \cdots, N\}} \).

A candidate is a triple of a relational variable, a number and a refinement type.

The input of this algorithm is definite formulas \(\{F_i\}_i\) and a goal formula
\(\psi\).

Then, let \( \Gamma_\true \) be \( \{F_i: \top\}_i \)
and \( \Gamma_\false \) be \( \{F_i: \bot \}_i \).

\begin{align*}
    \textbf{Initialize} &\quad
        \Longrightarrow
        \epsilon \mid \mid [N \leftarrow 0, \Gamma_0 \leftarrow \Gamma_\true]
        &&\\
    \textbf{Valid} &\quad
        \epsilon \mid \mid A \Longrightarrow \textit{Valid}
        &&\quad \textbf{if} \ \Gamma_{i} \vdash \Gamma_{i-1}, i < N
        \\
    \textbf{Unfold} &\quad
        \epsilon \mid \mid A \Longrightarrow
        \epsilon \mid \mid [\Gamma_{N+1} \leftarrow \Gamma_\false, N \leftarrow N + 1]
        &&\\
    %\textbf{Induction} &\quad
    %    \epsilon \mid \mid
    %    &&\\
    \textbf{Candidate} &\quad
        \epsilon \mid \mid A
        \Longrightarrow
        \langle X, N, \tau \rangle \mid \mid A
        && \quad \textbf{if} \ \Gamma_N \not \vdash \psi \COL
        \typebool{\true},\\
        &&&\quad (X, \tau) = \textbf{CEX}(\Gamma, \psi, \typebool{true})
        \\
    \textbf{Conflict} &\quad
        \langle X, i + 1, \tau \rangle M\mid \mid A
        \Longrightarrow
        M \mid \mid A[\Gamma_j \leftarrow \Gamma_j \cup \Gamma]_{j=1}^{i+1}
        &&\quad \textbf{if} \ \Gamma \subset \Gamma_i, \Gamma \vdash X \COL \tau
        \\
    \textbf{Decide} &\quad
        \langle X, i + 1, \tau \rangle M\mid \mid A
        \Longrightarrow
        \langle X', i, \tau' \rangle \langle X, i + 1, \tau \rangle M\mid \mid A \mid \mid A
        &&\quad \textbf{if} \ \Gamma_i \not\vdash X \COL \tau,\\
        &&&\quad (X', \tau') = \textbf{CEX}(\Gamma_i, X, \tau)
        \\
    \textbf{Model} &\quad
        \langle X, 0, \tau \rangle \mid \mid A \Rightarrow Model?
        &&\\
\end{align*}


\subsubsection{Algorithm of \( \mathbf{CEX} \)}

Input is a type environment \( \Gamma \), a goal formula \( \psi \)
or a relational variable \( X \) and a refinement type \( \tau \).

We consider the following two operators:
\begin{align*}
    \psi \Downarrow \typebool{\constraint} \quad
        &= \quad \psi \land \constraint
        \\
    \psi \Downarrow \typeint{x} \to \tau   \quad
        &= \quad \lambda x. \psi \Downarrow \tau
        \\
    \psi \Downarrow \tau_1 \to \tau_2 \quad
        &= \quad \lambda f. \psi \land f \in \tau_1 \Downarrow \tau_2
        \\
    \psi \in \typebool{\constraint} \quad
        &= \quad \not \theta \lor \psi
        \\
    \psi \in \typeint{x} \to \tau   \quad
        &
        \\
    \psi \in \tau_1 \to \tau_2 \quad
        &
        \\
\end{align*}

For a refinement type \( \tau \),
we write \( \sigma_\tau \) for \( \true \downarrow \tau \).

\subsection{Example}

\begin{align*}
    X x &=_\nu x \neq 0 \land X\ (x + 1) \\
    \psi  &=_\nu \forall x. x < 0 \lor X\ x
\end{align*}

We abbreviate \(\typeint{x}\) for \(x\), and \(\typebool{\theta}\) for
\(\theta\) in the following example.

\begin{itemize}
    \item Initialize: \(\Gamma_0 = \{X: x \rightarrow \top\}\)
    \item Unfold: \(\Gamma_0, \Gamma_1^0 = \{X: x \rightarrow \bot\}\)
    \item Candidate: \(\langle X, 1, 1 \rangle \mid \Gamma_0, \Gamma_1^0\)
    \item Conflict: \(\Gamma_0, \Gamma_1^1 = \{x \rightarrow x \geq 1\}\)
        since \(X: x \rightarrow x \geq 1 \in F(\Gamma_0)\) and \(\models 1 \geq 1\)
    \item Unfold: \(\Gamma_0, \Gamma_1^1, \Gamma_2^0 = \{X: x \rightarrow \bot\}\)
    \item Candidate and Conflicts: \(\Gamma_0, \Gamma_1^1, \Gamma_2^1 = \{x \rightarrow x \geq 1\}\)
    \item Valid since \(\Gamma_2^1 \vdash \psi: \typebool{\top} \)
        and \(\Gamma_2^1 \rightarrow \Gamma_1^1\)
\end{itemize}


\end{document}
