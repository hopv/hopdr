\documentclass[runningheads]{llncs}
\usepackage{amsmath, amssymb}
\usepackage{mathtools}
\usepackage{braket}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{mathpartir}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{algorithmic}
\usepackage{graphicx}

\newcommand \nhz{\(\nu\text{HFL}_\mathbb{Z}\)}
\newcommand \hflz {\(\text{HFL}_\mathbb{Z}\)}

\newcommand\COL{\mathbin{:}}

% nhz syntax
\newcommand \true {\textbf{tt}}
\newcommand \false {\textbf{ff}}
\newcommand \predicate {\textbf{p}}
\newcommand \arith {\textbf{a}}
\newcommand \operator {\mathbin{\textbf{op}}}
\newcommand \term {M}
\newcommand \atom {A}
\newcommand \goal {G}
\newcommand \definite {D}

% nu HFLz semantics
\newcommand {\val}[1]{[\![#1]\!]}
\newcommand {\vwt}[3][]{\val{\wt{#2}{#3}}(\alpha\ifthenelse{\isempty{#1}}{}{[#1]})}
\newcommand {\wta}[3]{\Gamma, #1 \vdash_H #2 : #3}
\newcommand {\vwta}[3]{\val{\wta{#1}{#2}{#3}}(\alpha)}

\newcommand {\valfun}{\alpha}
\newcommand {\domain}[1]{\mathcal{D}_{#1}}
\newcommand {\order}[1]{\sqsubseteq_{#1}}
\newcommand {\join}[1]{\sqcap_#1}
\newcommand {\meet}[1]{\sqcup_#1}
\newcommand \gfp {\textbf{gfp}}


% simple type
\newcommand \stypeint {\textbf{Int}}
\newcommand \stypebool {\bullet}
\newcommand \srtype {\rho} % simple result type
\newcommand \satype {\eta} % simple argument type
\newcommand \senv {\Gamma}
\newcommand \wt[3][]{\ifthenelse{\isempty{#1}}{\senv}{\senv, #1} \vdash_H #2: #3}

% refinement type syntax
\newcommand \constraint {\theta}
\newcommand \refty {\tau}
\newcommand \typeint[1]{{#1} : \stypeint}
\newcommand \typebool[1]{\stypebool \langle #1 \rangle}

% refinement type judgement
\newcommand \refines[2]{#1:: #2}
\newcommand \tenv {\Gamma}
\newcommand \wf[2][]{\tenv \vdash \refines{#1}{#2}}

% refinement type semantics
\newcommand {\semt}[1]{(\!|#1|\!)}
\newcommand {\mjudge}[2]{\tenv \models #1: #2}
\newcommand {\semsbt}[3][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation #3}
\newcommand {\wsemsbt}[4][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation_{#4} #3}
\newcommand {\srt}[2]{\semt{\wf{#1}{#2}}(\alpha)}
\newcommand {\srtg}[3][]{\semt{\wf{#2}{#3}}(\alpha[#1])}
\newcommand {\vc}[1]{[\!|#1|\!]}
\newcommand {\vtenv}[2][]{\val{#2}({\ifthenelse{\isempty{#1}}{\valfun}{#1}})}


\newlength\myindent
\setlength\myindent{2em}
\newcommand\bindent{%
  \begingroup
  \setlength{\itemindent}{\myindent}
  \addtolength{\algorithmicindent}{\myindent}
}
\newcommand\eindent{\endgroup}


\begin{document}

\section{Higher-order PDR}

The target problem is \nhz{} validity checking.
For the syntax of the target language, we adopt the following HES-like language,
which is equivalent to \nhz{} since we can translate them mutually.

\subsection{Target Language}

\begin{align*}
    \goal &\quad ::= \quad
          G \land G
          \mid G \lor G
          \mid \forall x. G
          \mid \atom
          \mid \constraint
         \\
    \definite &\quad ::= \quad X x_1 \cdots x_n =_\nu G
          \\
    \atom &\quad ::= \quad X\ M_1\ \cdots\ M_k\\
    \constraint &\quad ::= \quad \cdots
\end{align*}

We consider every definite formulas and goal formulas are simply typed.

Then \nhz{} validity checking is that given definite formulas
\( X_1 \bar{x_1} = \psi_1, \cdots X_n \bar{x_n} =  \psi_n \)
and a goal formula \( \psi \),
we check the validity of \( \psi \).

\subsection{refinement type}

\subsubsection{Syntax}

\begin{align*}
  &\textit{arithmetic expressions} &
  \arith &::=
  n
  \mid
  x
  \mid
  \operator(\arith_1, \cdots, \arith_n)
  \\
  &\textit{constraint formulas}&
  \constraint &::=
  \true
  \mid \false
  \mid \predicate(\arith_1, \cdots, \arith_n)
  \mid \constraint_1 \land \constraint_2
  \mid \constraint_1 \lor \constraint_2
  \\
  &\textit{refinement types}&
  \refty &::=
  \typebool{\theta}
  \mid \typeint{x} \rightarrow \refty
  \mid \refty_1 \rightarrow \refty_2
  \mid \refty_1 \land \refty_2
\end{align*}

\subsubsection{Semantics}

\begin{align*}
    \srt{\constraint}{\stypebool} &= \{\val{\tenv \vdash_c \constraint}(\alpha), \top \}\\
    \srt{\typeint{x} \rightarrow \refty}{\stypeint \rightarrow \srtype} &=
      \{f \in \domain{\stypeint \rightarrow \srtype} \mid \forall v \in \domain{\stypeint}. \\
          &\quad \quad f(v) \in \semt{\tenv, x \vdash \refty:: \srtype}(\alpha[x \mapsto v])\\
    \srt{\refty_1 \rightarrow \refty_2}{\srtype_1 \rightarrow \srtype_2} &= \{f \in \domain{\srtype_1 \rightarrow \srtype_2} \mid \forall v \in
        \srt{\refty_1}{\srtype_1}. \\
          &\quad \quad \quad f(v) \in \srt{\refty_2}{\srtype_2}\}
\end{align*}

\subsection{type system}

The same one as APLAS20

%\subsection{transformer}
%
%TODO: kaku
%
%\begin{align*}
%    F(\Gamma)
%    &= \Gamma \cup \{ F: \typeint{x_1} \rightarrow \cdots
%    \rightarrow \typeint{x_n} \rightarrow \typebool{\theta} \\
%    &\mid
%    F x_1 \cdots x_n = \psi, \Gamma, x_1: \stypeint, \cdots, x_n: \stypeint
%    \vdash^{-} \psi: \typebool{\theta}\ \}
%\end{align*}
%
%\subsection{interpolation}
%
%We consider the interpolation of types by subtyping. That is, given two
%refinement types \( \tau_1, \tau_2\) such that \( \tau_1 \prec \tau_2 \),
%we try to find a refinement type \( \tau \) such that \( \tau_1 \prec \tau \prec
%\tau_2 \) where the free variables of \( \tau \) is a subset of the free
%variables of \( \tau_1 \) and \( \tau_2 \).
%
%We assume that we have an algorithm for craig interpolation.
%Then, it is easy to interpolate just by comparing the refinement type at the
%same position.
%
%For example, assume \(
%(\typeint{x} \to \typebool{\theta_1}) \to \typebool{\theta_2}
%\prec
%(\typeint{x} \to \typebool{\theta_1'}) \to \typebool{\theta_2'}
%\), we consider two craig interpolations as follows
%\begin{align*}
%    &\theta_2' \rightarrow \theta_2'' \rightarrow \theta_2\\
%    &\theta_1' \rightarrow \theta_1'' \rightarrow \theta_1.
%\end{align*}
%Then we consider the refinement type
%\( \tau = \typeint{x} \to \typebool{\theta_1''}) \to \typebool{\theta_2''} \).
%From the construction, \( \tau_1 \prec \tau \prec \tau_2 \) holds.
%
%\begin{align*}
%\end{align*}
%
%
%\subsection{algorithm}
%
During the execution of the following algorithm,
we hold two states: candidates and current environments.
To specify them, we use notation \( M \mid \mid S \), where
\( M \) specify candidates and \( S \) is a current environment.
%
In an environment, there is two variables:
a current expansion number \( N \)
and a sequence of type environment \( \{\Gamma_i\}_{i \in \{1, \cdots, N\}} \).

A candidate is a triple of a relational variable, a number and a refinement type.

The input of this algorithm is definite formulas \(\{F_i\}_i\) and a goal formula
\(\psi\).

Then, let \( \Gamma_\true \) be \( \{F_i: \top\}_i \)
and \( \Gamma_\false \) be \( \{F_i: \bot \}_i \).

\begin{align*}
    \textbf{Initialize} &\quad
        \Longrightarrow
        \epsilon \mid \mid [N \leftarrow 0, \Gamma_0 \leftarrow F(\Gamma_\true)]
        &&\\
    \textbf{Valid} &\quad
        \epsilon \mid \mid A \Longrightarrow \textit{Valid}
        &&\quad \textbf{if} \ \Gamma_{i} \vdash \Gamma_{i-1}
        \\
    \textbf{Unfold} &\quad
        \epsilon \mid \mid A \Longrightarrow
        \epsilon \mid \mid [\Gamma_{N+1} \leftarrow \Gamma_\false, N \leftarrow N + 1]
        &&\quad \textbf{if} \ \Gamma_{N} \vdash \psi: \typebool{\true}
        \\
    %\textbf{Induction} &\quad
    %    \epsilon \mid \mid
    %    &&\\
    \textbf{Candidate} &\quad
        \epsilon \mid \mid A
        \Longrightarrow
        \langle \Gamma^M, N \rangle \mid \mid A
        && \quad \textbf{if} \ \Gamma_N \not \vdash \psi \COL
        \typebool{\true},\\
        &&&\quad \Gamma^M = \textbf{CEX}(\Gamma, \psi, \typebool{true})
        \\
    \textbf{Conflict} &\quad
        \langle \Gamma \cup \{X: \tau\}, i + 1 \rangle M\mid \mid A
        \Longrightarrow&&\\
        & \langle \Gamma, i+1 \rangle M
        \mid \mid A[\Gamma_j \leftarrow \Gamma_j \cup \{X: \tau''\}]_{j=1}^{i+1}
        \tau
        &&\quad \textbf{if} \  X: \tau' \in F(\Gamma), \tau' \prec \tau''
        \prec \tau
        \\
    \textbf{Decide} &\quad
        \langle \Gamma \cup \{X: \tau\}, i + 1 \rangle M\mid \mid A
        \Longrightarrow&&\\
        & \langle \Gamma', i \rangle \langle \Gamma \cup \{X: \tau\}, i+1 \rangle M
        \mid \mid A
        &&\quad \textbf{if} \ \Gamma_i \not\vdash X \COL \tau,\\
        &&&\quad \Gamma' = \textbf{CEX}(\Gamma_i, R(X), \tau)
        \\
    \textbf{Model} &\quad
        \langle X, 0, \tau \rangle \mid \mid A \Rightarrow Model?
        &&\\
\end{align*}


\subsubsection{Algorithm of \( \mathbf{CEX} \)}

Key idea of \(\textbf{CEX}(\Gamma, \psi, \tau) \) is to find a "good" type
environment \(\Gamma' \) such that \(\Gamma \cup \Gamma' \vdash \psi: \tau \).
In other words, CEX tries to find types which is not included in the current
type environment and useful to prove the judgement.

However, if you add some weak types to the type environment like \(\tau_\bot\),
the algorithm above can easily fail because proving such types is impossible.
So, we want to consider the condition "good".



%
%We consider the following two operators:
%\begin{align*}
%    \psi \Downarrow \typebool{\constraint} \quad
%        &= \quad \psi \land \constraint
%        \\
%    \psi \Downarrow \typeint{x} \to \tau   \quad
%        &= \quad \lambda x. \psi \Downarrow \tau
%        \\
%    \psi \Downarrow \tau_1 \to \tau_2 \quad
%        &= \quad \lambda f. \psi \land f \in \tau_1 \Downarrow \tau_2
%        \\
%    \psi \in \typebool{\constraint} \quad
%        &= \quad \lnot \theta \lor \psi
%        \\
%    \psi \in \typeint{x} \to \tau   \quad
%        &= \quad \forall x. \psi\ x \in \tau
%        \\
%    \psi \in \tau_1 \to \tau_2 \quad
%        &= \quad \psi\ (\true \Downarrow \tau_1) \in \tau_2
%        \\
%\end{align*}
%
%For a refinement type \( \tau \),
%we write \( \sigma_\tau \) for \( \true \Downarrow \tau \),
%which is proved to be a semantically least element which has
%type \( \tau \).
%
%Then we consider the algorithm of CEX.
%Input is a type environment \( \Gamma \), a goal formula \( \psi \)
%or a relational variable \( X \) and a refinement type \( \tau \).
%
%First, let the clause named \( X \) \( X x_1 \cdots x_n =_\nu \psi_X \).
%Therefore, the refinement type \( \tau \) must be a kind of
%\( \sigma_1 \rightarrow \cdots \rightarrow \sigma_n \rightarrow
%\typebool{\theta} \).
%Then, we consider all the occurences of relational variables and higher-order
%argument variables by the corresponding refinement types.
%For example, assume that \(X k = X (\lambda x. \forall y. x < y \lor k\ x) \),
%\( \Gamma = \{ X: (\typeint{x} \rightarrow \typebool{x \geq 0}) \rightarrow
%\typebool{\true} \)
%and \( \tau = (x \to \typebool{x > 0}) \to \typebool{\true}\),
%we can reduce the body of \( X \) to
%\( (\lambda k. \forall x. x < 0 \lor k\ x)
%(\lambda x. \forall y. x < y \lor (\lambda x. x > 0)\ x)
%\). And considering the \( \beta \) transform, this can be reduced to
%\( \forall x. x < 0 \lor \forall y. x < y \lor x > 0\). We let this formula \(
%\varphi \).
%
%Now, from the assumption that the we cannot derive the judgement,
%\( \true \Rightarrow \varphi \) i.e. \( \varphi \) does not hold.
%Then we get the counterexample of this formula by using SMT solver.
%For the above formula, we have \( x = 0, y = -1 \).
%
%By replacing the variable, we can generate a candidate
%\( (X, (\typeint{x} \to \typebool{x < -1 \lor x \geq 0}) \rightarrow
%\typebool{\true}) \).
%
%\subsection{Example}
%
%\begin{align*}
%    X x &=_\nu x \neq 0 \land X\ (x + 1) \\
%    \psi  &=_\nu \forall x. x < 0 \lor X\ x
%\end{align*}
%
%We abbreviate \(\typeint{x}\) for \(x\), and \(\typebool{\theta}\) for
%\(\theta\) in the following example.
%
%\begin{itemize}
%    \item Initialize: \(\Gamma_0 = \{X: x \rightarrow \top\}\)
%    \item Unfold: \(\Gamma_0, \Gamma_1^0 = \{X: x \rightarrow \bot\}\)
%    \item Candidate: \(\langle X, 1, 1 \rangle \mid \Gamma_0, \Gamma_1^0\)
%    \item Conflict: \(\Gamma_0, \Gamma_1^1 = \{x \rightarrow x \geq 1\}\)
%        since \(X: x \rightarrow x \geq 1 \in F(\Gamma_0)\) and \(\models 1 \geq 1\)
%    \item Unfold: \(\Gamma_0, \Gamma_1^1, \Gamma_2^0 = \{X: x \rightarrow \bot\}\)
%    \item Candidate and Conflicts: \(\Gamma_0, \Gamma_1^1, \Gamma_2^1 = \{x \rightarrow x \geq 1\}\)
%    \item Valid since \(\Gamma_2^1 \vdash \psi: \typebool{\top} \)
%        and \(\Gamma_2^1 \rightarrow \Gamma_1^1\)
%\end{itemize}
%
%\subsection{Example 2}
%
%\begin{align*}
%    Sum
%\end{align*}

\subsubsection{The problem of type checking}

In the middle of

Consider
\begin{align*}
    F\ x\ k =_\nu \forall y. y \neq x - 1 \lor
        & \{ (x > 0 \lor k\ x)\\
        & \land ( x \leq 0 \lor F\ y\ (L\ x\ k)) \}
\end{align*}
where \( L\ x\ k\ y =_\nu k\ (x + y) \).
We can prove the safety by the following type environment:

\begin{align*}
    F&: \typeint{x} \to (\typeint{y} \to \typebool{x \leq y}) \to
    \typebool{\true}\\
    L&: \typeint{x} \to (\typeint{z} \to \typebool{x \leq z}) \to
    \typeint{y}) \to \typebool{0 \leq y}
\end{align*}

Consider the following type environment \(\Gamma\)
\begin{align*}
    f&: (\typeint{x} \to \typebool{C_1}) \to ((\typeint{y} \to \typebool{C_2})
    \to \typebool{C_3})\\
    k&: \typeint{x} \to \typebool{C_4}\\
    g&: \typeint{x} \to \typebool{C_5}\\
    f'&: (\typeint{x} \to \typebool{C_1'}) \to ((\typeint{y} \to \typebool{C_2'})
    \to \typebool{C_3'})\\
    k'&: \typeint{x} \to \typebool{C_4'}\\
    g'&: \typeint{x} \to \typebool{C_5'}\\
    z&: \stypeint.
\end{align*}
We would like to prove \( \Gamma \vdash (f\ k\ g) \lor (f'\ k'\ g'):
\typebool{C}\)


\subsubsection{Algorithm of type checking}

\begin{algorithmic}
\STATE infer($\Gamma$, $f$) = ($\{\}$, $\Gamma(f)$)
\STATE infer($\Gamma$, $a\ x$) where $\Gamma(x) = \stypeint$ =
    \bindent
    \STATE let ($c, \typeint{y} \mapsto \tau$) = infer($\Gamma$, $a$) in
    \STATE ($[y/x]C, [y/x]\tau$)
    \eindent
\STATE infer($\Gamma$, $a_1\ a_2$) otherwise =
    \bindent
    \STATE let ($c_1, \sigma \mapsto \tau$) = infer($\Gamma$, $a_1$) in
    \STATE let ($c_2, \sigma'$) = infer($\Gamma$, $a_2$) in
    \STATE let ($\tau', L$) = generate\_template($\tau$) in
    \STATE let C = subtype($\sigma \mapsto \tau, \sigma'\mapsto \tau'$) in
    \STATE let C' = simplify($ C \cup C' \cup C'', L)$ in
    \STATE ($ C', \tau'$)
    \eindent
\STATE simplify(C, L) =
    \bindent
    \WHILE{let $P(\tilde{x}) \Leftarrow \psi$ where $P \not \in L$}
        \FORALL{$Q(\tilde{y}) \Leftarrow \psi' \land P(\tilde{x})$ in $C$}
            \STATE remove $P(\tilde{x}) \Leftarrow \psi$ from $C$
            \STATE add $Q(\tilde{y}) \Leftarrow \psi' \land \psi$ to $C$
        \ENDFOR
    \ENDWHILE
    \eindent

\end{algorithmic}

Consider the following type environment \(\Gamma\)
\begin{align*}
    f&: (\typeint{x} \to \typebool{C_1}) \to ((\typeint{x} \to \typebool{C_2})
    \to \typebool{C_3})\\
    g&: \typeint{x} \to \typebool{C_4}\\
    h&: (\typeint{x} \to \typebool{C_1'}) \to x \to \typebool{C_3'}\\
    i&: \typeint{x} \to \typebool{C_4'}\\
    y&: \stypeint
\end{align*}
Then, we try to check \(\Gamma \vdash (f\ g)\ (h\ i): \typebool{\true}\).
To do that, we first infer the type of this formula: infer\((\Gamma, (f\ g)\
(h\ i)\).
Observing that infer\((\Gamma, f\ g) = (C_1, (\typeint{x} \rightarrow
\typebool{P(x, y)}) \rightarrow \typebool{Q(y)} )\), infer\((\Gamma, f\ g)
= (C_2, \typeint{x} \rightarrow \typebool{R(x, y)})\),
generate\_template\((\typebool{Q(y)}) = (\typebool{Q'(y)}, \{Q'\})\)
where \(C_1\) is
\begin{align*}
    Q(y) \Rightarrow &C_3\\
    Q(y) \land \Rightarrow &P(x, y)\\
    Q(y) \land C_1  \Rightarrow &C_4
\end{align*}
and \(C_2\) is
\begin{align*}
    R(x, y) \Rightarrow &C_3'\\
    R(x, y) \land C_1'\Rightarrow &C_4',
\end{align*}
subtype\(( (\typeint{x} \to \typebool{P(x, y)}) \to \typebool{Q(y)} \prec
(\typeint{x} \to \typebool{R(x, y)}) \to \typebool{Q'(y)}) \) returns \(C_3\):
\begin{align*}
    Q'(y) \Rightarrow &Q(y)\\
    Q'(y) \land P(x, y) \Rightarrow &C_4'.
\end{align*}
Then, simplify\((C_1 \cup C_2 \cup C_3, \{Q'\})\) will be
\begin{align*}
    Q'(y) \Rightarrow &C_3\\
    Q'(y) \land C_2 \Rightarrow &C_3'\\
    Q'(y) \land C_2 \land C_1' \Rightarrow &C_4'\\
    Q'(y) \land C_1 \Rightarrow &C_4.
\end{align*}


\end{document}
