\documentclass[runningheads]{llncs}
\usepackage{amsmath, amssymb}
\usepackage{mathtools}
\usepackage{braket}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{mathpartir}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{color}


\newcommand \nhz{\(\nu\text{HFL}_\mathbb{Z}\)}
\newcommand \hflz {\(\text{HFL}_\mathbb{Z}\)}

\newcommand\COL{\mathbin{:}}

% nhz syntax
\newcommand \true {\textbf{tt}}
\newcommand \false {\textbf{ff}}
\newcommand \predicate {\textbf{p}}
\newcommand \arith {\textbf{a}}
\newcommand \operator {\mathbin{\textbf{op}}}
\newcommand \term {M}
\newcommand \atom {A}
\newcommand \goal {G}
\newcommand \definite {D}

% nu HFLz semantics
\newcommand {\val}[1]{[\![#1]\!]}
\newcommand {\vwt}[3][]{\val{\wt{#2}{#3}}(\alpha\ifthenelse{\isempty{#1}}{}{[#1]})}
\newcommand {\wta}[3]{\Gamma, #1 \vdash_H #2 : #3}
\newcommand {\vwta}[3]{\val{\wta{#1}{#2}{#3}}(\alpha)}

\newcommand {\valfun}{\alpha}
\newcommand {\domain}[1]{\mathcal{D}_{#1}}
\newcommand {\order}[1]{\sqsubseteq_{#1}}
\newcommand {\join}[1]{\sqcap_#1}
\newcommand {\meet}[1]{\sqcup_#1}
\newcommand \gfp {\textbf{gfp}}


% simple type
\newcommand \stypeint {\textbf{Int}}
\newcommand \stypebool {\bullet}
\newcommand \srtype {\rho} % simple result type
\newcommand \satype {\eta} % simple argument type
\newcommand \senv {\Gamma}
\newcommand \wt[3][]{\ifthenelse{\isempty{#1}}{\senv}{\senv, #1} \vdash_H #2: #3}

% refinement type syntax
\newcommand \constraint {\theta}
\newcommand \refty {\tau}
\newcommand \typeint[1]{{#1} : \stypeint}
\newcommand \typebool[1]{\stypebool \langle #1 \rangle}

% refinement type judgement
\newcommand \refines[2]{#1:: #2}
\newcommand \tenv {\Gamma}
\newcommand \wf[2][]{\tenv \vdash \refines{#1}{#2}}

% refinement type semantics
\newcommand {\semt}[1]{(\!|#1|\!)}
\newcommand {\mjudge}[2]{\tenv \models #1: #2}
\newcommand {\semsbt}[3][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation #3}
\newcommand {\wsemsbt}[4][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation_{#4} #3}
\newcommand {\srt}[2]{\semt{\wf{#1}{#2}}(\alpha)}
\newcommand {\srtg}[3][]{\semt{\wf{#2}{#3}}(\alpha[#1])}
\newcommand {\vc}[1]{[\!|#1|\!]}
\newcommand {\vtenv}[2][]{\val{#2}({\ifthenelse{\isempty{#1}}{\valfun}{#1}})}

\newcommand {\rdecide} {\emph{Decide}}
\newcommand {\rconflict} {\emph{Conflict}}
\newcommand {\rvalid} {\emph{Valid}}
\newcommand {\rcandidate} {\emph{Candidate}}
\newcommand {\runfold} {\emph{Unfold}}

\newlength\myindent
\setlength\myindent{2em}
\newcommand\bindent{%
  \begingroup
  \setlength{\itemindent}{\myindent}
  \addtolength{\algorithmicindent}{\myindent}
}
\newcommand\eindent{\endgroup}


\begin{document}

\section{Higher-order PDR}

The target problem is \nhz{} validity checking.
For the syntax of the target language, we adopt the following HES-like language,
which is equivalent to \nhz{} since we can translate them mutually.

\subsection{Target Language}

%\begin{align*}
%    \goal &\quad ::= \quad
%          G \land G
%          \mid G \lor G
%          \mid \forall x. G
%          \mid \atom
%          \mid \constraint
%         \\
%    \definite &\quad ::= \quad X x_1 \cdots x_n =_\nu G
%          \\
%    \atom &\quad ::= \quad X\ M_1\ \cdots\ M_k\\
%    \constraint &\quad ::= \quad \cdots
%\end{align*}
%
%We consider every definite formulas and goal formulas are simply typed.


Then \nhz{} validity checking is that given definite formulas
\( X_1 \bar{x_1} = \psi_1, \cdots X_n \bar{x_n} =  \psi_n \)
and a goal formula \( \psi \),
we check the validity of \( \psi \).

\subsection{refinement type}

\subsubsection{Syntax}

\begin{align*}
  &\textit{arithmetic expressions} &
  \arith &::=
  n
  \mid
  x
  \mid
  \operator(\arith_1, \cdots, \arith_n)
  \\
  &\textit{constraint formulas}&
  \constraint &::=
  \true
  \mid \false
  \mid \predicate(\arith_1, \cdots, \arith_n)
  \mid \constraint_1 \land \constraint_2
  \mid \constraint_1 \lor \constraint_2
  \\
  &\textit{refinement types}&
  \refty &::=
  \typebool{\theta}
  \mid \typeint{x} \rightarrow \refty
  \mid \refty_1 \rightarrow \refty_2
  \mid \refty_1 \land \refty_2
\end{align*}

\subsubsection{Semantics}

\begin{align*}
    \srt{\constraint}{\stypebool} &= \{\val{\tenv \vdash_c \constraint}(\alpha), \top \}\\
    \srt{\typeint{x} \rightarrow \refty}{\stypeint \rightarrow \srtype} &=
      \{f \in \domain{\stypeint \rightarrow \srtype} \mid \forall v \in \domain{\stypeint}. \\
          &\quad \quad f(v) \in \semt{\tenv, x \vdash \refty:: \srtype}(\alpha[x \mapsto v])\\
    \srt{\refty_1 \rightarrow \refty_2}{\srtype_1 \rightarrow \srtype_2} &= \{f \in \domain{\srtype_1 \rightarrow \srtype_2} \mid \forall v \in
        \srt{\refty_1}{\srtype_1}. \\
          &\quad \quad \quad f(v) \in \srt{\refty_2}{\srtype_2}\}
\end{align*}

\subsection{type system}

The same one as APLAS20

%
%\subsection{interpolation}
%
%We consider the interpolation of types by subtyping. That is, given two
%refinement types \( \tau_1, \tau_2\) such that \( \tau_1 \prec \tau_2 \),
%we try to find a refinement type \( \tau \) such that \( \tau_1 \prec \tau \prec
%\tau_2 \) where the free variables of \( \tau \) is a subset of the free
%variables of \( \tau_1 \) and \( \tau_2 \).
%
%We assume that we have an algorithm for craig interpolation.
%Then, it is easy to interpolate just by comparing the refinement type at the
%same position.
%
%For example, assume \(
%(\typeint{x} \to \typebool{\theta_1}) \to \typebool{\theta_2}
%\prec
%(\typeint{x} \to \typebool{\theta_1'}) \to \typebool{\theta_2'}
%\), we consider two craig interpolations as follows
%\begin{align*}
%    &\theta_2' \rightarrow \theta_2'' \rightarrow \theta_2\\
%    &\theta_1' \rightarrow \theta_1'' \rightarrow \theta_1.
%\end{align*}
%Then we consider the refinement type
%\( \tau = \typeint{x} \to \typebool{\theta_1''}) \to \typebool{\theta_2''} \).
%From the construction, \( \tau_1 \prec \tau \prec \tau_2 \) holds.
%
%\begin{align*}
%\end{align*}
%
%
%\subsection{algorithm}
%

\subsection{linear HoPDR}

During the execution of the following algorithm,
we hold two states: candidates and current environments.
To specify them, we use notation \( M \mid \mid S \), where
\( M \) specify candidates and \( S \) is a current environment.
%
In an environment, there is two variables:
a current expansion number \( N \)
and a sequence of type environment \( \{\Gamma_i\}_{i \in \{1, \cdots, N\}} \). Note that type environments admit multiple items of the same name: \( x: \tau_1, x: \tau_2 \), meaning that the intersection type \( x: \tau_1 \wedge \tau_2 \).

A candidate is a triple of a relational variable, a number and a refinement type.

The input of this algorithm is definite formulas \(\{F_i\}_i\) and a goal formula
\(\psi\).

Then, let \( \Gamma_\true \) be \( \{F_i: \tau_\top\}_i \)
and \( \Gamma_\false \) be \( \{F_i: \tau_\bot \}_i \).
We write \( \Gamma \vdash \Gamma' \) when for any \( F \COL \tau \in \Gamma' \)
and \( \Gamma \vdash \psi_F \COL \tau \).

\begin{align*}
    \textbf{Initialize} &\quad
        \Longrightarrow
        \epsilon \mid \mid [\Gamma_1 \leftarrow F(\Gamma_\true)]
        &&\\
    \textbf{Valid} &\quad
        \epsilon \mid \mid A \Longrightarrow \textit{Valid}
        &&\quad \textbf{if} \ \Gamma_{i} \vdash \Gamma_{i-1}
        \\
    \textbf{Unfold} &\quad
        \epsilon \mid \mid A \Longrightarrow
        \epsilon \mid \mid A[\Gamma_{N+1} \leftarrow \Gamma_\false]
        &&\quad \textbf{if} \ \Gamma_{N} \vdash \psi: \typebool{\true}
        \\
    \textbf{Candidate} &\quad
        \epsilon \mid \mid A
        \Longrightarrow
        \langle \Gamma^N, N \rangle \mid \mid A
        && \quad \textbf{if} \ \Gamma_N \not \vdash \psi \COL
        \typebool{\true},\\
        &&&\quad \Gamma^N = \textbf{CEX}(\Gamma, \psi, \typebool{\true})
        \\
    \textbf{Conflict} &\quad
        \langle \Gamma \cup \{X: \tau\}, i + 1 \rangle M\mid \mid A
        \Longrightarrow&&\\
        & \langle \Gamma, i+1 \rangle M
        \mid \mid A[\Gamma_j \leftarrow \Gamma_j \cup \{X: \tau'\}]_{j=1}^{i+1}
        &&\quad \textbf{if} \  \Gamma_i \vdash \psi_X \COL \tau' \text{ and }
        \Gamma_i \vdash \tau' \prec \tau
        \\
    \textbf{Decide} &\quad
        \langle \Gamma \cup \{X: \tau\}, i + 1 \rangle M\mid \mid A
        \Longrightarrow&&\\
        & \langle \Gamma', i \rangle \langle \Gamma \cup \{X: \tau\}, i+1 \rangle M
        \mid \mid A
        &&\quad \textbf{if} \ \Gamma_i \not\vdash \psi_X \COL \tau,\\
        &&&\quad \Gamma' = \textbf{CEX}(\Gamma_i, \psi_X, \tau)
        \\
    \textbf{Model} &\quad
        \langle \Gamma, 0 \rangle M \mid \mid A \Rightarrow Invalid
        &&\\
\end{align*}




\subsubsection{Algorithm of \( \mathbf{CEX} \)}


\textcolor{red}{I'm unsure about this part.}


Key idea of \(\textbf{CEX}(\Gamma, \psi, \tau) \) is to find a "good" type
environment \(\Gamma' \) such that \(\Gamma \cup \Gamma' \vdash \psi: \tau \).
In other words, CEX tries to find types which is not included in the current
type environment and useful to prove the judgement.

However, if you add some weak types to the type environment like \(\tau_\bot\),
the algorithm above can easily fail because proving such types is impossible.
So, we want to consider the condition "good".

We consider the following two operators:
\begin{align*}
    \psi \Downarrow \typebool{\constraint} \quad
        &= \quad \psi \land \constraint
        \\
    \psi \Downarrow \typeint{x} \to \tau   \quad
        &= \quad \lambda x. \psi \Downarrow \tau
        \\
    \psi \Downarrow \tau_1 \to \tau_2 \quad
        &= \quad \lambda f. \psi \land f \in \tau_1 \Downarrow \tau_2
        \\
    \psi \in \typebool{\constraint} \quad
        &= \quad \lnot \theta \lor \psi
        \\
    \psi \in \typeint{x} \to \tau   \quad
        &= \quad \forall x. \psi\ x \in \tau
        \\
    \psi \in \tau_1 \to \tau_2 \quad
        &= \quad \psi\ (\true \Downarrow \tau_1) \in \tau_2
        \\
\end{align*}

For a refinement type \( \tau \),
we write \( \sigma_\tau \) for \( \true \Downarrow \tau \),
which is proved to be a semantically least element which has
type \( \tau \).

Then we consider the algorithm of CEX.
The input of CEX is a type environment \( \Gamma \), a formula \( \psi \)
and a refinement type \( \tau \).

%First, let the clause named \( X \) \( X x_1 \cdots x_n =_\nu \psi_X \).
%Therefore, the refinement type \( \tau \) must be a kind of
%\( \sigma_1 \rightarrow \cdots \rightarrow \sigma_n \rightarrow
%\typebool{\theta} \).
Then, we consider all the occurrences of relational variables and higher-order
argument variables by the corresponding refinement types.
For example, assume that \(M = X F \) and
\( \Gamma = \{ X: (\typeint{x} \rightarrow \typebool{x \geq 0}) \rightarrow
\typebool{\true}, F: \typeint{x} \rightarrow \typebool{x > 0 } \).
Here we want to prove that \( M \) has type \( \typebool{\true} \), which is
not hold.
Taking the least formula which has type \( \Gamma(X) \), we can write \( X F \)
as
\( (\lambda k. \forall x. x < 0 \lor k\ x)
(\lambda x. x > 0) \).
And considering \( \beta \) transform, this can be reduced to
\( \forall x. x < 0 \lor x > 0 \). We let \( \varphi \) be this formula.

Now, from the assumption that the we cannot derive the judgement,
\( \true \Rightarrow \varphi \) i.e. \( \varphi \) does not hold.
Then we get the counterexample of \( \varphi \) by using SMT solver.
For the above formula, we have \( x = 0 \).

By replacing the variable, we can generate a candidate
\( \Gamma^M = \{ X \COL (\typeint{x} \to \typebool{x= -1 \lor x \geq 0}) \rightarrow
\typebool{\true}) \).

\subsection{transformer}
てすと
\textcolor{red}{I'm unsure about this part.}

The definition of the type environment transformer is as follows:

\begin{align*}
    F(\Gamma) = \left \{ X \COL \tau \mid
        \Gamma \vdash \psi_X \COL \tau \right \}.
\end{align*}

(I think the condition that \( \tau \in F(\Gamma) \) has no element \( \tau' \in F(\Gamma) \)
such that \( \tau' \prec \tau \) may be needed. not sure.. )
%
%It is easy to check if \( F(\Gamma) \ni X \COL \tau \) since
%it's done by checking \( \Gamma \vdash \psi_X \COL \tau \).
%
%However, to find a good refinement type, we want to find a type \( \tau' \)
%such that \(F(\Gamma) \ni X \COL \tau' \) and \(\tau' \prec \tau \).
%
%\begin{align*}
%    F'(\Gamma)
%    &= \Gamma \cup \{ F: \typeint{x_1} \rightarrow \cdots
%    \rightarrow \typeint{x_n} \rightarrow \typebool{\theta} \\
%    &\mid
%    F x_1 \cdots x_n = \psi, \Gamma, x_1: \stypeint, \cdots, x_n: \stypeint
%    \vdash^{-} \psi: \typebool{\theta}\ \}
%\end{align*}

\subsubsection{Easier example（高階）}

\begin{align*}
    H\ x\ y &= y < x \\
    F\ x\ g &= g\ x\\
    G\ x\ g &= F\ (-x)\ g\\
    M &= \forall x. x \leq 0 \lor G\ x\ (H\ 0)
\end{align*}

\( \Gamma_1 =
\{ H \COL \typeint{x} \to \typeint{y} \to \typebool{y < x},
F \COL \typeint{x} \to (\typeint{y} \to \typebool{\false}) \to \typebool{\false},
G \COL \typeint{x} \to (\typeint{y} \to \typebool{\false}) \to \typebool{\true}
\}
\)

\runfold{}
\(
\Gamma_2 = \{ H \COL \typeint{x} \to \typeint{y} \to \typebool{y < x},
F \COL \typeint{x} \to (\typeint{y} \to \typebool{\true}) \to \typebool{\false},
G \COL \typeint{x} \to (\typeint{y} \to \typebool{\true}) \to \typebool{\false}
\}
\)

\rcandidate{}
\(
M = x = 1, y = 0
\)
というのも、\( G\ x \COL (\typeint{y} \to \typebool{\top}) \to \typebool{\false} \) が \( H\ 0 \COL (\typeint{y} \to \typebool{y < 0}) \to \typebool{x > 0} \)が不成立。
すなわち、Gの型か、Hの型が悪い

Gの引数側の型を広げるか、Hの型を狭めることで対処しないといけない

\( H \COL \typeint{x} \to \typeint{y} \to \typeint{x = 0 \wedge y = 0} \)
もしくは
\( G \COL \typeint{x} \to (\typeint{y} \to \typebool{x \neq 1 \lor y \neq 0}) \to \typebool{x = 1} \)

前者は、\( \Gamma_1 \not \vdash H \COL \typeint{x} \to \typeint{y} \to \typeint{x = 0 \wedge y = 0} \) で、Invalid。
後者は、\( \Gamma_1 \vdash G \COL \typeint{x} \to (\typeint{y} \to \typebool{x \neq 1 \lor y \neq 0}) \to \typebool{x = 1} \)。

特に、\( \typeint{x} \to (\typeint{y} \to \typebool{y < 0}) \to \typebool{x > 0} \prec \typeint{x} \to (\typeint{y} \to \typebool{x \neq 1 \lor y \neq 0}) \to \typebool{x = 1} \) なので、\( \typeint{x} \to (\typeint{y} \to \typebool{y < 0}) \to \typebool{x > 0} \)をconjoin

以下 \( \runfold{} \) など

高階のケースも、実質的にnon-linearなケースと似たような形になる？

\subsubsection{Example}

First order case

\begin{align*}
    X x &=_\nu x \neq 0 \land X\ (x + 1) \\
    \psi  &=_\nu \forall x. x \leq 0 \lor X\ x
\end{align*}

We abbreviate \(\typeint{x}\) for \(x\), and \(\typebool{\theta}\) for
\(\theta\) in the following example.

\begin{itemize}
    \item Initialize: \(\Gamma_0 = F(\{X \COL x \rightarrow \top\}) = \{ X \COL
        \typeint{x} \to \typebool{x \neq 0} \} \)
    \item Unfold: \(\Gamma_0, \Gamma_1 = \{X \COL x \rightarrow \bot\}\)
    \item Candidate: \(\Gamma^1 = \{ X \COL \typeint{x} \to \typebool{x = 1} \} \mid \Gamma_0, \Gamma_1\)
    \item Conflict: \(\Gamma_0, \Gamma_1 \leftarrow \{X \COL \typeint{x}
        \typebool{x \geq 1}\}\)
        since \(X: \typeint{x} \to \typebool{x \neq -1 \land x \neq 0 } \in F(\Gamma_0)\) and \(
        \typeint{x} \to \typebool{x \neq -1 \land x \neq 0 } \prec \typeint{x} \to \typebool{x \geq 1} \prec \typeint{x} \to \typebool{x =
        1}\)
    \item Unfold: \(\Gamma_0, \Gamma_1, \Gamma_2 = \{X: x \rightarrow \bot\}\)
    \item Candidate and Conflicts: \(\Gamma_0, \Gamma_1, \Gamma_2 \leftarrow \{X
        \COL \typeint{x} \to \typebool{x \geq 1} \}\)
    \item Valid since \(\Gamma_2 \vdash \psi: \typebool{\top} \)
        and \(\Gamma_2 \vdash \Gamma_1 \)
\end{itemize}

\subsection{Example running of Higher order PDR}

\textcolor{red}{I'm unsure about this part as well. a rough sketch}

First, we consider a positive case.

\begin{align*}
    S\ n\ k\ &=_\nu (n > 0 \vee k\ n)
                    \wedge (n \leq 0 \vee S\ (n - 1)\ (L\ n\ k));\\
    K\ n\ m &=_\nu (m \geq n);\\
    L\ n\ k \ m &=_\nu k\ (n + m);\\
    M &= \forall n. S\ n\ (K\ n);
\end{align*}

Let \( \Gamma_\true \) be a type environment
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\false}) \to
        \typebool{\true}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{\true}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{\false}) \to
        \typeint{m} \to \typebool{\true}
    \end{array}
    \right\}
\]
Then we let \( \Gamma_1 = F(\Gamma_\true) \).
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\false}) \to
        \typebool{n > 0}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{m \geq n}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{m \geq n}) \to
        \typeint{m} \to \typebool{m \geq 0}
    \end{array}
    \right\}
\]

Next, we do \rvalid{} and let \( \Gamma_2 = \Gamma_\false \), that is,
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\true}) \to
        \typebool{\false}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{\false}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{\true}) \to
        \typeint{m} \to \typebool{\false}
    \end{array}
    \right\}
\]


Now, we cannot typecheck \( \Gamma_2 \vdash M \COL \typebool{\true} \),
therefore, we have a counterexample \( \Gamma^2 = \{
K \COL \typeint{n} \to \typeint{m} \to \typebool{m = 0 \land n = 0},
S \COL \typeint{n} \to (\typeint{m} \to
\typebool{n = 0 \land m = 0}) \to \typebool{n = 0} \} \).
Then, we check \( \Gamma_0 \vdash S \COL \typeint{n} \to (\typeint{m} \to
\typebool{n = 0 \land m = 0}) \to \typebool{n = 0} \).
This holds.

Now, we want to "devise" a good refinement type \( \tau \) such that
\( \Gamma_0 \vdash S \COL \tau \) and \( \Gamma \vdash \tau \prec \typeint{n}
\to (\typeint{m} \to \typebool{m = 0 \land n = 0}) \to \typebool{n = 0} \).
Assume we can get \( \tau = \typeint{n} \to (\typeint{m} \to \typebool{m \leq
0}) \to \typebool{\true} \).

Then, we do \rconflict{}; that is, we add \( S \COL \tau \) to \( \Gamma_2 \).
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\true}) \to
        \typebool{\false}\\
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{m \leq 0}) \to
        \typebool{\true}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{\false}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{\true}) \to
        \typeint{m} \to \typebool{\false}
    \end{array}
    \right\}
\]
Next, we do another \rconflict{} for \( K \in \Gamma^2 \) and
we have \( K \COL \typeint{n} \to \typeint{m} \to \typebool{m \leq 0} \).
We now removed all the types in \( \Gamma^2 \) and \( \Gamma_2 \) is
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\true}) \to
        \typebool{\false}\\
        S \COL \typeint{n} \to (\typeint{m} \to \typebool{m \leq 0}) \to
        \typebool{\true}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{\false}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{m \leq 0}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{\true}) \to
        \typeint{m} \to \typebool{\false}
    \end{array}
    \right\}.
\]

Now that we can prove \( \Gamma_2 \vdash M \COL \typebool{\true} \), we do
\rvalid{}, and let \( \Gamma_3 = \Gamma_\false \).

\rcandidate{}
\begin{align*} \Gamma^3 = \{
    &K \COL \typeint{n} \to \typeint{m} \to \typebool{n = 1},\\
&S \COL \typeint{n} \to (\typeint{m} \to
\typebool{n = 1}) \to \typebool{n = 1} \}
\end{align*}.

\rdecide{}
\( \Gamma_2 \not \vdash S \COL \typeint{n} \to (\typeint{m} \to
\typebool{m = 1 \land n = 1}) \to \typebool{n = 1} \)

\begin{align*} \Gamma^2 = \{
        &L \COL \typeint{n} \to (\typeint{m} \to \typebool{n = 1}) \to
        \typeint{m} \to \typebool{n = 0}\\
    &S \COL \typeint{n} \to (\typeint{m} \to \typebool{n = 0}) \to \typebool{n = 1} \}
\end{align*}.

\vdots

\subsubsection{The problem of type checking}

In the middle of

Consider
\begin{align*}
    F\ x\ k =_\nu \forall y. y \neq x - 1 \lor
        & \{ (x > 0 \lor k\ x)\\
        & \land ( x \leq 0 \lor F\ y\ (L\ x\ k)) \}
\end{align*}
where \( L\ x\ k\ y =_\nu k\ (x + y) \).
We can prove the safety by the following type environment:

\begin{align*}
    F&: \typeint{x} \to (\typeint{y} \to \typebool{x \leq y}) \to
    \typebool{\true}\\
    L&: \typeint{x} \to (\typeint{z} \to \typebool{x \leq z}) \to
    \typeint{y}) \to \typebool{0 \leq y}
\end{align*}

Consider the following type environment \(\Gamma\)
\begin{align*}
    f&: (\typeint{x} \to \typebool{C_1}) \to ((\typeint{y} \to \typebool{C_2})
    \to \typebool{C_3})\\
    k&: \typeint{x} \to \typebool{C_4}\\
    g&: \typeint{x} \to \typebool{C_5}\\
    f'&: (\typeint{x} \to \typebool{C_1'}) \to ((\typeint{y} \to \typebool{C_2'})
    \to \typebool{C_3'})\\
    k'&: \typeint{x} \to \typebool{C_4'}\\
    g'&: \typeint{x} \to \typebool{C_5'}\\
    z&: \stypeint.
\end{align*}
We would like to prove \( \Gamma \vdash (f\ k\ g) \lor (f'\ k'\ g'):
\typebool{C}\)


\subsubsection{Algorithm of type checking}

\begin{algorithmic}
\STATE infer($\Gamma$, $f$) = ($\{\}$, $\Gamma(f)$)
\STATE infer($\Gamma$, $a\ x$) where $\Gamma(x) = \stypeint$ =
    \bindent
    \STATE let ($c, \typeint{y} \mapsto \tau$) = infer($\Gamma$, $a$) in
    \STATE ($[y/x]C, [y/x]\tau$)
    \eindent
\STATE infer($\Gamma$, $a_1\ a_2$) otherwise =
    \bindent
    \STATE let ($c_1, \sigma \mapsto \tau$) = infer($\Gamma$, $a_1$) in
    \STATE let ($c_2, \sigma'$) = infer($\Gamma$, $a_2$) in
    \STATE let ($\tau', L$) = generate\_template($\tau$) in
    \STATE let C = subtype($\sigma \mapsto \tau, \sigma'\mapsto \tau'$) in
    \STATE let C' = simplify($ C \cup C' \cup C'', L)$ in
    \STATE ($ C', \tau'$)
    \eindent
\STATE simplify(C, L) =
    \bindent
    \WHILE{let $P(\tilde{x}) \Leftarrow \psi$ where $P \not \in L$}
        \FORALL{$Q(\tilde{y}) \Leftarrow \psi' \land P(\tilde{x})$ in $C$}
            \STATE remove $P(\tilde{x}) \Leftarrow \psi$ from $C$
            \STATE add $Q(\tilde{y}) \Leftarrow \psi' \land \psi$ to $C$
        \ENDFOR
    \ENDWHILE
    \eindent

\end{algorithmic}

Consider the following type environment \(\Gamma\)
\begin{align*}
    f&: (\typeint{x} \to \typebool{C_1}) \to ((\typeint{x} \to \typebool{C_2})
    \to \typebool{C_3})\\
    g&: \typeint{x} \to \typebool{C_4}\\
    h&: (\typeint{x} \to \typebool{C_1'}) \to x \to \typebool{C_3'}\\
    i&: \typeint{x} \to \typebool{C_4'}\\
    y&: \stypeint
\end{align*}
Then, we try to check \(\Gamma \vdash (f\ g)\ (h\ i): \typebool{\true}\).
To do that, we first infer the type of this formula: infer\((\Gamma, (f\ g)\
(h\ i)\).
Observing that infer\((\Gamma, f\ g) = (C_1, (\typeint{x} \rightarrow
\typebool{P(x, y)}) \rightarrow \typebool{Q(y)} )\), infer\((\Gamma, f\ g)
= (C_2, \typeint{x} \rightarrow \typebool{R(x, y)})\),
generate\_template\((\typebool{Q(y)}) = (\typebool{Q'(y)}, \{Q'\})\)
where \(C_1\) is
\begin{align*}
    Q(y) \Rightarrow &C_3\\
    Q(y) \land \Rightarrow &P(x, y)\\
    Q(y) \land C_1  \Rightarrow &C_4
\end{align*}
and \(C_2\) is
\begin{align*}
    R(x, y) \Rightarrow &C_3'\\
    R(x, y) \land C_1'\Rightarrow &C_4',
\end{align*}
subtype\(( (\typeint{x} \to \typebool{P(x, y)}) \to \typebool{Q(y)} \prec
(\typeint{x} \to \typebool{R(x, y)}) \to \typebool{Q'(y)}) \) returns \(C_3\):
\begin{align*}
    Q'(y) \Rightarrow &Q(y)\\
    Q'(y) \land P(x, y) \Rightarrow &C_4'.
\end{align*}
Then, simplify\((C_1 \cup C_2 \cup C_3, \{Q'\})\) will be
\begin{align*}
    Q'(y) \Rightarrow &C_3\\
    Q'(y) \land C_2 \Rightarrow &C_3'\\
    Q'(y) \land C_2 \land C_1' \Rightarrow &C_4'\\
    Q'(y) \land C_1 \Rightarrow &C_4.
\end{align*}



\subsection{non-linear extension}

GPDRの論文で言う、linearなCHCは、APLAS20の論文でtractableと読んでいたものに対応。今回は簡単のため、non-linear

counterexampleは、ラベル付き木を成すものとする。ラベルは、型環境と展開数のタプルであり、空の木を \( \epsilon \)、木Tの中のノードNを、その子供のノード\( C_1, \cdots C_n \) を用いて、\( T[N \bullet C_1\ C_2\cdots C_n] \) と表す


次にnon-linearなものを扱えるようにするために、PDR実行中に保持する状態を
現在の最大の展開数を \( N \)としたときに、counterexampleの列と
\( \Gamma_1 \cdots \Gamma_N \)のタプルとする。

つまり、単一のcounterexample（列）から、複数のcounterexample（木）となる。
これは、toplevelの述語もnon-linearになりうるので、その場合複数の木が生える。

non-linearの拡張として一部のルールを以下のように変更

\begin{align*}
    \textbf{Candidate} &\quad
        \epsilon \mid \mid A
        \Longrightarrow
        \langle \Gamma_1^N, \cdots \Gamma_n^N, N \rangle \mid \mid A
        && \quad \textbf{if} \ \Gamma_N \not \vdash \psi \COL
        \typebool{\true},\\
        &&&\quad \Gamma_1^N, \cdots \Gamma_n^N = \textbf{CEX}(\Gamma, \psi, \typebool{\true})
        \\
    \textbf{Conflict} &\quad
        T[\langle \Gamma \cup \{X: \tau\}, i + 1 \rangle], \cdots \mid \mid A
        \Longrightarrow&&\\
        & T[\langle \Gamma, i + 1 \rangle], \cdots
        \mid \mid A[\Gamma_j \leftarrow \Gamma_j \cup \{X: \tau'\}]_{j=1}^{i+1}
        &&\quad \textbf{if} \  \Gamma_i \vdash \psi_X \COL \tau' \text{ and }
        \Gamma_i \vdash \tau' \prec \tau
        \\
    \textbf{Decide} &\quad
         T[\langle\Gamma \cup \{X: \tau\}, i + 1 \rangle],  \cdots\mid \mid A
        \Longrightarrow&&\\
        &  T[\langle\Gamma \cup \{X: \tau\}, i + 1 \rangle \bullet \langle\Gamma_1^i, i\rangle, \cdots], \cdots
        \mid \mid A
        &&\quad \textbf{if} \ \Gamma_i \not\vdash \psi_X \COL \tau,\\
        &&&\quad \Gamma_1^i, \cdots, \Gamma_n^i = \textbf{CEX}(\Gamma_i, \psi_X, \tau)
        \\
    \textbf{Model} &\quad
        \langle T, \cdots \rangle M \mid \mid A \Rightarrow Invalid
        &&\quad \textbf{if Tの全ての葉が展開数0になったとき} \
        \\
\end{align*}


\subsection{non-linear extension example}

\begin{align*}
    F(x) &= x \neq 0 \wedge F\ (x+1) \\
    G(x) &= x \neq 0 \wedge G\ (x-1)  \\
    M    &= \forall x. x=0 \lor F\ x \lor G\ x
\end{align*}

\begin{itemize}
    \item Initialize: \(\Gamma_0 = F(\{X \COL x \rightarrow \top\}) = \{ X \COL
        \typeint{x} \to \typebool{x \neq 0} \} \)
    \item Unfold: \(\Gamma_0, \Gamma_1 = \{X \COL x \rightarrow \bot\}\)
\end{itemize}

\end{document}

