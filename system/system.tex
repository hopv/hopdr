\documentclass[runningheads]{llncs}
\usepackage{amsmath, amssymb}
\usepackage{mathtools}
\usepackage{braket}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{mathpartir}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{color}
\usepackage{bcprules}


\newcommand \nhz{\(\nu\text{HFL}_\mathbb{Z}\)}
\newcommand \hflz {\(\text{HFL}_\mathbb{Z}\)}

\newcommand\COL{\mathbin{:}}

% nhz syntax
\newcommand \true {\textbf{tt}}
\newcommand \false {\textbf{ff}}
\newcommand \predicate {\textbf{p}}
\newcommand \arith {\textbf{a}}
\newcommand \operator {\mathbin{\textbf{op}}}
\newcommand \term {M}
\newcommand \atom {A}
\newcommand \goal {G}
\newcommand \definite {D}

% nu HFLz semantics
\newcommand {\val}[1]{[\![#1]\!]}
\newcommand {\vwt}[3][]{\val{\wt{#2}{#3}}(\alpha\ifthenelse{\isempty{#1}}{}{[#1]})}
\newcommand {\wta}[3]{\Gamma, #1 \vdash_H #2 : #3}
\newcommand {\vwta}[3]{\val{\wta{#1}{#2}{#3}}(\alpha)}

\newcommand {\valfun}{\alpha}
\newcommand {\domain}[1]{\mathcal{D}_{#1}}
\newcommand {\order}[1]{\sqsubseteq_{#1}}
\newcommand {\join}[1]{\sqcap_#1}
\newcommand {\meet}[1]{\sqcup_#1}
\newcommand \gfp {\textbf{gfp}}


% simple type
\newcommand \stypeint {\textbf{Int}}
\newcommand \stypebool {\bullet}
\newcommand \stypeboolf {\circ}
\newcommand \srtype {\rho} % simple result type
\newcommand \satype {\eta} % simple argument type
\newcommand \senv {\Gamma}
\newcommand \wt[3][]{\ifthenelse{\isempty{#1}}{\senv}{\senv, #1} \vdash_H #2: #3}

% refinement type syntax
\newcommand \constraint {\theta}
\newcommand \refty {\tau}
\newcommand \typeint[1]{{#1} : \stypeint}
\newcommand \typebool[1]{\stypebool \langle #1 \rangle}
\newcommand \typeboolf[1]{\stypeboolf \langle #1 \rangle}

% refinement type judgement
\newcommand \refines[2]{#1:: #2}
\newcommand \tenv {\Gamma}
\newcommand \wf[2]{\tenv \vdash \refines{#1}{#2}}

% refinement type semantics
\newcommand {\semt}[1]{(\!|#1|\!)_\bullet}
\newcommand {\mjudge}[2]{\tenv \models #1 \COL #2}
\newcommand {\semsbt}[3][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation #3}
\newcommand {\wsemsbt}[4][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation_{#4} #3}
\newcommand {\srt}[2]{\semt{\wf{#1}{#2}}(\alpha)}
\newcommand {\srtg}[3][]{\semt{\wf{#2}{#3}}(\alpha[#1])}
\newcommand {\vc}[1]{[\!|#1|\!]}
\newcommand {\vtenv}[2][]{\val{#2}({\ifthenelse{\isempty{#1}}{\valfun}{#1}})}

% PDR rules
\newcommand {\rdecide} {\emph{Decide}}
\newcommand {\rconflict} {\emph{Conflict}}
\newcommand {\rvalid} {\emph{Valid}}
\newcommand {\rcandidate} {\emph{Candidate}}
\newcommand {\runfold} {\emph{Unfold}}

% false types
\newcommand {\fenv} {\Delta} % false type environment
\newcommand {\semtf}[1]{(\!|#1|\!)_\circ}
\newcommand {\srtf}[2]{\semtf{\wf{#1}{#2}}(\alpha)}

% conflict relation
\newcommand {\conflict}{\wedge}
\newcommand {\consistent}{\sim}

\newlength\myindent
\setlength\myindent{2em}
\newcommand\bindent{%
  \begingroup
  \setlength{\itemindent}{\myindent}
  \addtolength{\algorithmicindent}{\myindent}
}
\newcommand\eindent{\endgroup}


\begin{document}

\section{Higher-order PDR}

The target problem is \nhz{} validity checking.
For the syntax of the target language, we adopt the following HES-like language,
which is equivalent to \nhz{} since we can translate them mutually.

\subsection{Target Language}

\begin{align*}
    \goal &\quad ::= \quad
          G \land G
          \mid G \lor G
          \mid \forall x. G
          \mid \atom
          \mid \constraint
         \\
    \definite &\quad ::= \quad X x_1 \cdots x_n =_\nu G
          \\
    \atom &\quad ::= \quad X \mid A_1\ A_2\\
    \constraint &\quad ::= \quad \cdots
\end{align*}


Then \nhz{} validity checking is that given definite formulas
\( X_1 \bar{x_1} = \psi_1, \cdots X_n \bar{x_n} =  \psi_n \)
and a goal formula \( \psi \),
we check the validity of \( \psi \).

\subsection{refinement type}

\subsubsection{Syntax}

\begin{align*}
  &\textit{arithmetic expressions} &
  \arith &::=
  n
  \mid
  x
  \mid
  \operator(\arith_1, \cdots, \arith_n)
  \\
  &\textit{constraint formulas}&
  \constraint &::=
  \true
  \mid \false
  \mid \predicate(\arith_1, \cdots, \arith_n)
  \mid \constraint_1 \land \constraint_2
  \mid \constraint_1 \lor \constraint_2
  \\
  &\textit{refinement types}&
  \refty &::=
  \typebool{\theta}
  \mid \typeint{x} \rightarrow \refty
  \mid \refty_1 \rightarrow \refty_2
  %\mid \refty_1 \land \refty_2
  \\
  &\textit{false types}&
  \sigma &::=
  \typeboolf{\theta}
  \mid \typeint{x} \rightarrow \sigma
  \mid \sigma_1 \rightarrow \sigma_2
\end{align*}

\subsubsection{Semantics}

\begin{align*}
    \srt{\typebool{\constraint}}{\stypebool} &= \{\val{\tenv \vdash_c \constraint}(\alpha), \top \}\\
    \srt{\typeint{x} \rightarrow \refty}{\stypeint \rightarrow \srtype} &=
      \{f \in \domain{\stypeint \rightarrow \srtype} \mid \forall v \in \domain{\stypeint}. \\
          &\quad \quad f(v) \in \semt{\tenv, x \vdash \refty:: \srtype}(\alpha[x \mapsto v])\\
    \srt{\refty_1 \rightarrow \refty_2}{\srtype_1 \rightarrow \srtype_2} &= \{f \in \domain{\srtype_1 \rightarrow \srtype_2} \mid \forall v \in
        \srt{\refty_1}{\srtype_1}. \\
          &\quad \quad \quad f(v) \in \srt{\refty_2}{\srtype_2}\}
\end{align*}
and
\begin{align*}
    \srtf{\typeboolf{\constraint}}{\stypebool} &= \{\val{\tenv \vdash_c \lnot \constraint}(\alpha), \bot \}\\
    \srtf{\typeint{x} \rightarrow \sigma}{\stypeint \rightarrow \srtype} &=
      \{f \in \domain{\stypeint \rightarrow \srtype} \mid \forall v \in \domain{\stypeint}. \\
          &\quad \quad f(v) \in \semtf{\tenv, x \vdash \sigma :: \srtype}(\alpha[x \mapsto v])\\
    \srtf{\sigma_1 \rightarrow \sigma_2}{\srtype_1 \rightarrow \srtype_2} &= \{f \in \domain{\srtype_1 \rightarrow \srtype_2} \mid \forall v \in
        \srtf{\sigma_1}{\srtype_1}. \\
          &\quad \quad \quad f(v) \in \srtf{\sigma_2}{\srtype_2}\}
\end{align*}

\subsubsection{type system for false types}

\infrule[F-App]{
  \fenv \vdash \psi_1 : \sigma_1 \rightarrow \sigma_2
  \andalso \fenv \vdash \psi_2 : \sigma_2
}{
  \fenv \vdash \psi_1\ \psi_2 : \sigma_2
}

\infrule[F-AppInt]{
  \fenv \vdash \psi_1 \COL \typeint{x} \rightarrow \sigma
}{
  \fenv \vdash \psi_1\ n \COL [n/x]\sigma
}

\infrule[F-Conj]{
  \fenv \vdash \psi_1 : \typeboolf{\theta_1}
  \andalso \fenv \vdash \psi_2 \COL \typeboolf{\theta_2}
}{
  \fenv \vdash \psi_1 \land \psi_2 \COL \typeboolf{\theta_1 \lor \theta_2}
}

\infrule[F-Disj]{
  \fenv \vdash \psi_1 : \typeboolf{\theta}
  \andalso \fenv \vdash \psi_2 \COL \typeboolf{\theta}
}{
  \fenv \vdash \psi_1 \lor \psi_2 \COL \typeboolf{\theta}
}

\infrule[F-Constr]{}{
  \fenv \vdash \theta \COL \typeboolf{\lnot \theta}
}

\infrule[F-Var]{}{
  \fenv, x \COL \sigma \vdash x \COL \sigma
}

\subsection{HoPDR}

\subsubsection{State}

PDR hold two states: a candidate and an approximation \( M \mid \mid A \).

A candidate is a labeled tree. Each node is labeled with a tuple of false type
judgement and step index
\( \langle X \COL \sigma, i \rangle \). The root of a candidate tree always have
\( \epsilon \) tag for the simplicity.
Let \( \epsilon \) be a tree which holds only \( \epsilon \) node
and we write \( T[L \bullet \{C_1\ C_2\cdots C_n\}] \) to mean \( T \) has a node with label \( L \) and its children are \( C_1, \cdots C_n \).

An approximation is a sequence of refinement type environments \( \Gamma_1, \Gamma_2, \cdots, \Gamma_N \).
Note that type environments admit multiple items of the same name: \( x: \tau_1, x: \tau_2 \), meaning that the intersection type \( x: \tau_1 \wedge \tau_2 \).

\subsubsection{Conflict relation}

We define two relations \( \Gamma \vdash \sigma \conflict \tau \) and
\( \Gamma \vdash \sigma \consistent \tau \) by


\infrule[C-Prop]{\alpha \models \theta_1 \land \theta_2}{
  \Gamma \vdash \typeboolf{\theta_1} \conflict \typebool{\theta_2}
}

\infrule[C-Prop-Dual]{\models \lnot (\theta_1 \land \theta_2)}{
  \Gamma \vdash \typeboolf{\theta_1} \consistent \typebool{\theta_2}
}

\infrule[C-Int-Pred]{\Gamma, \typeint{x} \vdash \sigma \conflict \tau}{
  \Gamma \vdash \typeint{x} \to \sigma \conflict \typeint{x} \to \tau
}

\infrule[C-Int-Pred-Dual]{\Gamma, \typeint{x} \vdash \sigma \consistent \tau}{
  \Gamma \vdash \typeint{x} \to \sigma \consistent \typeint{x} \to \tau
}

\infrule[C-Pred]{
\Gamma \vdash \sigma_1 \consistent \tau_1
\andalso \Gamma \vdash \sigma_2 \conflict \tau_2}{
  \Gamma \vdash \sigma_1 \to \sigma_2 \conflict \tau_1 \to \tau_2
}
\infrule[C-Pred-Dual]{
\Gamma \vdash \sigma_1 \conflict \tau_1
\andalso \Gamma \vdash \sigma_1 \consistent \tau_1}{
  \Gamma \vdash \sigma_1 \to \sigma_2 \consistent \tau_1 \to \tau_2
}

Intuitively, \( \Gamma \vdash \sigma \conflict \tau \) means that
there is no formula which have both \( \sigma \) and \( \tau \) type; \( \Gamma \vdash \sigma \consistent \tau \) is the dual of it.


\begin{lemma}[Soundness of conflict]
\label{lemma:conflict}
For any type environment \( \Gamma \), simple type \( \rho \), false type \( \vdash \sigma :: \rho \) and refinement type \( \vdash \tau :: \rho \), the followings hold:
\begin{itemize}
    \item \( \Gamma \vdash \sigma \conflict \tau \Rightarrow
    \exists \alpha \in \val{\Gamma}.
    \semtf{\Gamma \vdash \sigma}(\alpha) \cap \semt{\Gamma \vdash \tau}(\alpha) = \emptyset \)

    \item \( \Gamma \vdash \sigma \consistent \tau \Rightarrow
    \forall \alpha \in \val{\Gamma}.
    \semtf{\Gamma \vdash \sigma}(\alpha) \cap \semt{\Gamma \vdash \tau}(\alpha) \neq \emptyset \).
\end{itemize}
\end{lemma}

\begin{proof}
By induction on the structure of the simple type \( \rho \).
\end{proof}

TBD: Completeness (not sure whether it holds)

For a type environment \( \Gamma \), a false type \( \sigma \) and a variable \( X \), we write \( X : \sigma \consistent \Gamma \) for \( \forall X \COL \tau \in \Gamma. \vdash \sigma \consistent \tau \) and \(X : \sigma \conflict \Gamma\)
for \( \exists X \COL \tau \in \Gamma. \vdash \sigma \conflict \tau \).

\subsubsection{Algorithm Specification}

The input of this algorithm is definite formulas \(\{F_i\}_i\) and a goal formula
\(\psi\).

Then, let \( \Gamma_\true \) be \( \{F_i: \tau_\top\}_i \)
and \( \Gamma_\false \) be \( \{F_i: \tau_\bot \}_i \).
We write \( \Gamma \vdash \Gamma' \) when for any \( F \COL \tau \in \Gamma' \)
and \( \Gamma \vdash \psi_F \COL \tau \).

\begin{align*}
    \textbf{Initialize} &\quad
        \Longrightarrow
        \epsilon \mid \mid [\Gamma_0 \leftarrow \Gamma_\true]
        &&\\
    \textbf{Valid} &\quad
        \epsilon \mid \mid A \Longrightarrow \textit{Valid}
        &&\quad \textbf{if} \ \Gamma_{i} \vdash \Gamma_{i-1}
        \\
    \textbf{Unfold} &\quad
        \epsilon \mid \mid A \Longrightarrow
        \epsilon \mid \mid A[\Gamma_{N+1} \leftarrow \Gamma_\false]
        &&\quad \textbf{if} \ \Gamma_{N} \vdash \psi: \typebool{\true}
        \\
    \textbf{Candidate} &\quad
        \epsilon \mid \mid A
        \Longrightarrow&&\\
        & \epsilon[\epsilon \bullet \langle X_1 \COL \sigma_1, N \rangle, \cdots, \langle X_n \COL \sigma_n, N \rangle]\mid \mid A
        && \quad \textbf{if} \ \Gamma_N \not \vdash \psi \COL
        \typebool{\true},\\
        &&&\quad  X_1 \COL \sigma_1 , \cdots, X_n \COL \sigma_n= \textbf{CEX}(\Gamma, \psi, \typeboolf{\true})
        \\
    \textbf{Conflict} &\quad
        T[L \bullet \langle X_1: \sigma_1, i + 1 \rangle, \cdots,
                     \langle X_n: \sigma_n, i + 1 \rangle
        ] \mid \mid A
        \Longrightarrow&&\\
        & T[L]
        \mid \mid A[\Gamma_j \leftarrow \Gamma_j \cup \{X_k: \tau'\}]_{j=1}^{i+1}
        &&\quad \textbf{if} \  \exists k \in [1, n].
        X_k \COL \sigma_k \conflict F(\Gamma_i) \\
        &&&\quad \quad \text{ and } X_k \COL \tau' \in F(\Gamma)
        \\
    \textbf{Decide} &\quad
         T[\langle X: \sigma, i + 1 \rangle], \cdots\mid \mid A
        \Longrightarrow&&\\
        &  T[\langle X: \sigma, i + 1 \rangle
                \bullet \langle X_1 \COL \sigma_1, i\rangle, \cdots,
                        \langle X_n \COL \sigma_n, i\rangle]
        \mid \mid A
        &&\quad \textbf{if} \ X \COL \sigma \consistent F(\Gamma_i),\\
        &&&\quad  X_1 \COL \sigma_1, \cdots, X_n \COL \sigma_n=
        \textbf{CEX}(\Gamma_i, \psi_X, \sigma)
        \\
    \textbf{Model} &\quad
        T \mid \mid A \Rightarrow Invalid
        &&\quad \textbf{if} \text{ all the leaves of } T \text{ are } \langle \_, 0 \rangle \
        \\
\end{align*}




\subsubsection{Algorithm of \( \mathbf{CEX} \)}

\( \textbf{CEX}(\Gamma, \psi, \sigma) \) is a type inference routine of false types.
Given \( \Gamma \), \( \psi \) and \( \sigma \),
\( \textbf{CEX}(\Gamma, \psi, \sigma) \) returns a false type environment \( \fenv \) such that
\( \Gamma \sim \fenv \) and \( \fenv \vdash \psi \COL \sigma \).



%%%%%%%%%


\subsubsection{Easier example（高階）}

\begin{align*}
    H\ x\ y &= y < x \\
    F\ x\ g &= g\ x\\
    G\ x\ g &= F\ (-x)\ g\\
    M &= \forall x. x \leq 0 \lor G\ x\ (H\ 0)
\end{align*}

\( \Gamma_1 =
\{ H \COL \typeint{x} \to \typeint{y} \to \typebool{y < x},
F \COL \typeint{x} \to (\typeint{y} \to \typebool{\false}) \to \typebool{\false},
G \COL \typeint{x} \to (\typeint{y} \to \typebool{\false}) \to \typebool{\true}
\}
\)

\runfold{}
\(
\Gamma_2 = \{ H \COL \typeint{x} \to \typeint{y} \to \typebool{y < x},
F \COL \typeint{x} \to (\typeint{y} \to \typebool{\true}) \to \typebool{\false},
G \COL \typeint{x} \to (\typeint{y} \to \typebool{\true}) \to \typebool{\false}
\}
\)

\rcandidate{}
\(
M = x = 1, y = 0
\)
というのも、\( G\ x \COL (\typeint{y} \to \typebool{\top}) \to \typebool{\false} \) が \( H\ 0 \COL (\typeint{y} \to \typebool{y < 0}) \to \typebool{x > 0} \)が不成立。
すなわち、Gの型か、Hの型が悪い

Gの引数側の型を広げるか、Hの型を狭めることで対処しないといけない

\( H \COL \typeint{x} \to \typeint{y} \to \typeint{x = 0 \wedge y = 0} \)
もしくは
\( G \COL \typeint{x} \to (\typeint{y} \to \typebool{x \neq 1 \lor y \neq 0}) \to \typebool{x = 1} \)

前者は、\( \Gamma_1 \not \vdash H \COL \typeint{x} \to \typeint{y} \to \typeint{x = 0 \wedge y = 0} \) で、Invalid。
後者は、\( \Gamma_1 \vdash G \COL \typeint{x} \to (\typeint{y} \to \typebool{x \neq 1 \lor y \neq 0}) \to \typebool{x = 1} \)。

特に、\( \typeint{x} \to (\typeint{y} \to \typebool{y < 0}) \to \typebool{x > 0} \prec \typeint{x} \to (\typeint{y} \to \typebool{x \neq 1 \lor y \neq 0}) \to \typebool{x = 1} \) なので、\( \typeint{x} \to (\typeint{y} \to \typebool{y < 0}) \to \typebool{x > 0} \)をconjoin

以下 \( \runfold{} \) など

高階のケースも、実質的にnon-linearなケースと似たような形になる？

\subsubsection{Example}

First order case

\begin{align*}
    X x &=_\nu x \neq 0 \land X\ (x + 1) \\
    \psi  &=_\nu \forall x. x \leq 0 \lor X\ x
\end{align*}

We abbreviate \(\typeint{x}\) for \(x\), and \(\typebool{\theta}\) for
\(\theta\) in the following example.

\begin{itemize}
    \item Initialize: \(\Gamma_0 = F(\{X \COL x \rightarrow \top\}) = \{ X \COL
        \typeint{x} \to \typebool{x \neq 0} \} \)
    \item Unfold: \(\Gamma_0, \Gamma_1 = \{X \COL x \rightarrow \bot\}\)
    \item Candidate: \(\Gamma^1 = \{ X \COL \typeint{x} \to \typebool{x = 1} \} \mid \Gamma_0, \Gamma_1\)
    \item Conflict: \(\Gamma_0, \Gamma_1 \leftarrow \{X \COL \typeint{x}
        \typebool{x \geq 1}\}\)
        since \(X: \typeint{x} \to \typebool{x \neq -1 \land x \neq 0 } \in F(\Gamma_0)\) and \(
        \typeint{x} \to \typebool{x \neq -1 \land x \neq 0 } \prec \typeint{x} \to \typebool{x \geq 1} \prec \typeint{x} \to \typebool{x =
        1}\)
    \item Unfold: \(\Gamma_0, \Gamma_1, \Gamma_2 = \{X: x \rightarrow \bot\}\)
    \item Candidate and Conflicts: \(\Gamma_0, \Gamma_1, \Gamma_2 \leftarrow \{X
        \COL \typeint{x} \to \typebool{x \geq 1} \}\)
    \item Valid since \(\Gamma_2 \vdash \psi: \typebool{\top} \)
        and \(\Gamma_2 \vdash \Gamma_1 \)
\end{itemize}

\subsection{Example running of Higher order PDR}

\textcolor{red}{I'm unsure about this part as well. a rough sketch}

First, we consider a positive case.

\begin{align*}
    S\ n\ k\ &=_\nu (n > 0 \vee k\ n)
                    \wedge (n \leq 0 \vee S\ (n - 1)\ (L\ n\ k));\\
    K\ n\ m &=_\nu (m \geq n);\\
    L\ n\ k \ m &=_\nu k\ (n + m);\\
    M &= \forall n. S\ n\ (K\ n);
\end{align*}

Let \( \Gamma_\true \) be a type environment
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\false}) \to
        \typebool{\true}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{\true}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{\false}) \to
        \typeint{m} \to \typebool{\true}
    \end{array}
    \right\}
\]
Then we let \( \Gamma_1 = F(\Gamma_\true) \).
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\false}) \to
        \typebool{n > 0}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{m \geq n}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{m \geq n}) \to
        \typeint{m} \to \typebool{m \geq 0}
    \end{array}
    \right\}
\]

Next, we do \rvalid{} and let \( \Gamma_2 = \Gamma_\false \), that is,
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\true}) \to
        \typebool{\false}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{\false}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{\true}) \to
        \typeint{m} \to \typebool{\false}
    \end{array}
    \right\}
\]


Now, we cannot typecheck \( \Gamma_2 \vdash M \COL \typebool{\true} \),
therefore, we have a counterexample \( \Gamma^2 = \{
K \COL \typeint{n} \to \typeint{m} \to \typebool{m = 0 \land n = 0},
S \COL \typeint{n} \to (\typeint{m} \to
\typebool{n = 0 \land m = 0}) \to \typebool{n = 0} \} \).
Then, we check \( \Gamma_0 \vdash S \COL \typeint{n} \to (\typeint{m} \to
\typebool{n = 0 \land m = 0}) \to \typebool{n = 0} \).
This holds.

Now, we want to "devise" a good refinement type \( \tau \) such that
\( \Gamma_0 \vdash S \COL \tau \) and \( \Gamma \vdash \tau \prec \typeint{n}
\to (\typeint{m} \to \typebool{m = 0 \land n = 0}) \to \typebool{n = 0} \).
Assume we can get \( \tau = \typeint{n} \to (\typeint{m} \to \typebool{m \leq
0}) \to \typebool{\true} \).

Then, we do \rconflict{}; that is, we add \( S \COL \tau \) to \( \Gamma_2 \).
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\true}) \to
        \typebool{\false}\\
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{m \leq 0}) \to
        \typebool{\true}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{\false}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{\true}) \to
        \typeint{m} \to \typebool{\false}
    \end{array}
    \right\}
\]
Next, we do another \rconflict{} for \( K \in \Gamma^2 \) and
we have \( K \COL \typeint{n} \to \typeint{m} \to \typebool{m \leq 0} \).
We now removed all the types in \( \Gamma^2 \) and \( \Gamma_2 \) is
\[
    \left\{
    \begin{array}{l}
        S \COL \typeint{n} \to(\typeint{m} \to \typebool{\true}) \to
        \typebool{\false}\\
        S \COL \typeint{n} \to (\typeint{m} \to \typebool{m \leq 0}) \to
        \typebool{\true}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{\false}\\
        K \COL \typeint{n} \to \typeint{m} \to \typebool{m \leq 0}\\
        L \COL \typeint{n} \to (\typeint{m} \to \typebool{\true}) \to
        \typeint{m} \to \typebool{\false}
    \end{array}
    \right\}.
\]

Now that we can prove \( \Gamma_2 \vdash M \COL \typebool{\true} \), we do
\rvalid{}, and let \( \Gamma_3 = \Gamma_\false \).

\rcandidate{}
\begin{align*} \Gamma^3 = \{
    &K \COL \typeint{n} \to \typeint{m} \to \typebool{n = 1},\\
&S \COL \typeint{n} \to (\typeint{m} \to
\typebool{n = 1}) \to \typebool{n = 1} \}
\end{align*}.

\rdecide{}
\( \Gamma_2 \not \vdash S \COL \typeint{n} \to (\typeint{m} \to
\typebool{m = 1 \land n = 1}) \to \typebool{n = 1} \)

\begin{align*} \Gamma^2 = \{
        &L \COL \typeint{n} \to (\typeint{m} \to \typebool{n = 1}) \to
        \typeint{m} \to \typebool{n = 0}\\
    &S \COL \typeint{n} \to (\typeint{m} \to \typebool{n = 0}) \to \typebool{n = 1} \}
\end{align*}.

\vdots

\subsubsection{The problem of type checking}

In the middle of

Consider
\begin{align*}
    F\ x\ k =_\nu \forall y. y \neq x - 1 \lor
        & \{ (x > 0 \lor k\ x)\\
        & \land ( x \leq 0 \lor F\ y\ (L\ x\ k)) \}
\end{align*}
where \( L\ x\ k\ y =_\nu k\ (x + y) \).
We can prove the safety by the following type environment:

\begin{align*}
    F&: \typeint{x} \to (\typeint{y} \to \typebool{x \leq y}) \to
    \typebool{\true}\\
    L&: \typeint{x} \to (\typeint{z} \to \typebool{x \leq z}) \to
    \typeint{y}) \to \typebool{0 \leq y}
\end{align*}

Consider the following type environment \(\Gamma\)
\begin{align*}
    f&: (\typeint{x} \to \typebool{C_1}) \to ((\typeint{y} \to \typebool{C_2})
    \to \typebool{C_3})\\
    k&: \typeint{x} \to \typebool{C_4}\\
    g&: \typeint{x} \to \typebool{C_5}\\
    f'&: (\typeint{x} \to \typebool{C_1'}) \to ((\typeint{y} \to \typebool{C_2'})
    \to \typebool{C_3'})\\
    k'&: \typeint{x} \to \typebool{C_4'}\\
    g'&: \typeint{x} \to \typebool{C_5'}\\
    z&: \stypeint.
\end{align*}
We would like to prove \( \Gamma \vdash (f\ k\ g) \lor (f'\ k'\ g'):
\typebool{C}\)


\subsubsection{Algorithm of type checking}

\begin{algorithmic}
\STATE infer($\Gamma$, $f$) = ($\{\}$, $\Gamma(f)$)
\STATE infer($\Gamma$, $a\ x$) where $\Gamma(x) = \stypeint$ =
    \bindent
    \STATE let ($c, \typeint{y} \mapsto \tau$) = infer($\Gamma$, $a$) in
    \STATE ($[y/x]C, [y/x]\tau$)
    \eindent
\STATE infer($\Gamma$, $a_1\ a_2$) otherwise =
    \bindent
    \STATE let ($c_1, \sigma \mapsto \tau$) = infer($\Gamma$, $a_1$) in
    \STATE let ($c_2, \sigma'$) = infer($\Gamma$, $a_2$) in
    \STATE let ($\tau', L$) = generate\_template($\tau$) in
    \STATE let C = subtype($\sigma \mapsto \tau, \sigma'\mapsto \tau'$) in
    \STATE let C' = simplify($ C \cup C' \cup C'', L)$ in
    \STATE ($ C', \tau'$)
    \eindent
\STATE simplify(C, L) =
    \bindent
    \WHILE{let $P(\tilde{x}) \Leftarrow \psi$ where $P \not \in L$}
        \FORALL{$Q(\tilde{y}) \Leftarrow \psi' \land P(\tilde{x})$ in $C$}
            \STATE remove $P(\tilde{x}) \Leftarrow \psi$ from $C$
            \STATE add $Q(\tilde{y}) \Leftarrow \psi' \land \psi$ to $C$
        \ENDFOR
    \ENDWHILE
    \eindent

\end{algorithmic}

Consider the following type environment \(\Gamma\)
\begin{align*}
    f&: (\typeint{x} \to \typebool{C_1}) \to ((\typeint{x} \to \typebool{C_2})
    \to \typebool{C_3})\\
    g&: \typeint{x} \to \typebool{C_4}\\
    h&: (\typeint{x} \to \typebool{C_1'}) \to x \to \typebool{C_3'}\\
    i&: \typeint{x} \to \typebool{C_4'}\\
    y&: \stypeint
\end{align*}
Then, we try to check \(\Gamma \vdash (f\ g)\ (h\ i): \typebool{\true}\).
To do that, we first infer the type of this formula: infer\((\Gamma, (f\ g)\
(h\ i)\).
Observing that infer\((\Gamma, f\ g) = (C_1, (\typeint{x} \rightarrow
\typebool{P(x, y)}) \rightarrow \typebool{Q(y)} )\), infer\((\Gamma, f\ g)
= (C_2, \typeint{x} \rightarrow \typebool{R(x, y)})\),
generate\_template\((\typebool{Q(y)}) = (\typebool{Q'(y)}, \{Q'\})\)
where \(C_1\) is
\begin{align*}
    Q(y) \Rightarrow &C_3\\
    Q(y) \land \Rightarrow &P(x, y)\\
    Q(y) \land C_1  \Rightarrow &C_4
\end{align*}
and \(C_2\) is
\begin{align*}
    R(x, y) \Rightarrow &C_3'\\
    R(x, y) \land C_1'\Rightarrow &C_4',
\end{align*}
subtype\(( (\typeint{x} \to \typebool{P(x, y)}) \to \typebool{Q(y)} \prec
(\typeint{x} \to \typebool{R(x, y)}) \to \typebool{Q'(y)}) \) returns \(C_3\):
\begin{align*}
    Q'(y) \Rightarrow &Q(y)\\
    Q'(y) \land P(x, y) \Rightarrow &C_4'.
\end{align*}
Then, simplify\((C_1 \cup C_2 \cup C_3, \{Q'\})\) will be
\begin{align*}
    Q'(y) \Rightarrow &C_3\\
    Q'(y) \land C_2 \Rightarrow &C_3'\\
    Q'(y) \land C_2 \land C_1' \Rightarrow &C_4'\\
    Q'(y) \land C_1 \Rightarrow &C_4.
\end{align*}



\subsection{non-linear extension}

GPDRの論文で言う、linearなCHCは、APLAS20の論文でtractableと読んでいたものに対応。今回は簡単のため、non-linear

counterexampleは、ラベル付き木を成すものとする。ラベルは、型環境と展開数のタプルであり、空の木を \( \epsilon \)、木Tの中のノードNを、その子供のノード\( C_1, \cdots C_n \) を用いて、\( T[N \bullet C_1\ C_2\cdots C_n] \) と表す


次にnon-linearなものを扱えるようにするために、PDR実行中に保持する状態を
現在の最大の展開数を \( N \)としたときに、counterexampleの列と
\( \Gamma_1 \cdots \Gamma_N \)のタプルとする。

つまり、単一のcounterexample（列）から、複数のcounterexample（木）となる。
これは、toplevelの述語もnon-linearになりうるので、その場合複数の木が生える。

non-linearの拡張として一部のルールを以下のように変更

\begin{align*}
    \textbf{Candidate} &\quad
        \epsilon \mid \mid A
        \Longrightarrow
        \langle \Gamma_1^N, \cdots \Gamma_n^N, N \rangle \mid \mid A
        && \quad \textbf{if} \ \Gamma_N \not \vdash \psi \COL
        \typebool{\true},\\
        &&&\quad \Gamma_1^N, \cdots \Gamma_n^N = \textbf{CEX}(\Gamma, \psi, \typebool{\true})
        \\
    \textbf{Conflict} &\quad
        T[\langle \Gamma \cup \{X: \tau\}, i + 1 \rangle], \cdots \mid \mid A
        \Longrightarrow&&\\
        & T[\langle \Gamma, i + 1 \rangle], \cdots
        \mid \mid A[\Gamma_j \leftarrow \Gamma_j \cup \{X: \tau'\}]_{j=1}^{i+1}
        &&\quad \textbf{if} \  \Gamma_i \vdash \psi_X \COL \tau' \text{ and }
        \Gamma_i \vdash \tau' \prec \tau
        \\
    \textbf{Decide} &\quad
         T[\langle\Gamma \cup \{X: \tau\}, i + 1 \rangle],  \cdots\mid \mid A
        \Longrightarrow&&\\
        &  T[\langle\Gamma \cup \{X: \tau\}, i + 1 \rangle \bullet \langle\Gamma_1^i, i\rangle, \cdots], \cdots
        \mid \mid A
        &&\quad \textbf{if} \ \Gamma_i \not\vdash \psi_X \COL \tau,\\
        &&&\quad \Gamma_1^i, \cdots, \Gamma_n^i = \textbf{CEX}(\Gamma_i, \psi_X, \tau)
        \\
    \textbf{Model} &\quad
        \langle T, \cdots \rangle M \mid \mid A \Rightarrow Invalid
        &&\quad \textbf{if Tの全ての葉が展開数0になったとき} \
        \\
\end{align*}


\subsection{non-linear extension example}

\begin{align*}
    F(x) &= x \neq 0 \wedge F\ (x+1) \\
    G(x) &= x \neq 0 \wedge G\ (x-1)  \\
    M    &= \forall x. x=0 \lor F\ x \lor G\ x
\end{align*}

\begin{itemize}
    \item Initialize: \(\Gamma_0 = F(\{X \COL x \rightarrow \top\}) = \{ X \COL
        \typeint{x} \to \typebool{x \neq 0} \} \)
    \item Unfold: \(\Gamma_0, \Gamma_1 = \{X \COL x \rightarrow \bot\}\)
\end{itemize}

\end{document}

