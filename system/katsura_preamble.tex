

% general
\newcommand \Nat {\mathbb{Z}}
\newcommand \Def {::=}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\fv}{fv}
\newcommand \gfp {\textbf{gfp}}
\newcommand {\model} {\mathcal{M}}

% algorithmic
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% crossref
% \crefname{theorem}{Theorem}{Theorems}
% \crefname{example}{Example}{Examples}
% \crefname{lemma}{Lemma}{Lemmas}
% \crefname{definition}{Definition}{Definitions}
% \crefname{table}{Table}{Tables}

% newtheorem
\newtheorem{prop}{Property}


% names
\newcommand \nhz{\(\nu\text{HFL}_\Nat\)}
\newcommand \hflz {\(\text{HFL}_\Nat\)}
\newcommand \pahfl{\textsc{PaHFL}}
\newcommand \rethfl{{\sc ReTHFL}}
\newcommand \horus{Horus}
\newcommand \hopdr {{\sc HoPDR}}
\newcommand \nhfl{\(\nu\text{HFL}\)}
\newcommand \oursolver {{\sc PDRHFL}}
\newcommand \infertype {{\sc InferConflict}}
\newcommand \collecttypes {{\sc CollectTypes}}
\newcommand \hoice{{\sc HoIce} }
\newcommand \genderivation {{\sc GenDerivation}}
%\newcommand \mochi{{\sc MoCHi} }


\newcommand\COL{\mathbin{:}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{conjecture}{Conjecture}
\newtheorem{theorem}{Theorem}

% general math

% nhz syntax
\newcommand \formula {\varphi}
\newcommand \goal {\varphi}
\newcommand \true {\textbf{tt}}
\newcommand \false {\textbf{ff}}
\newcommand \predicate {\textbf{p}}
\newcommand \arith {\textbf{a}}
\newcommand \operator {\mathbin{\textbf{op}}}
\newcommand \term {M}
\newcommand \atom {A}
\newcommand \definite {D}

% nu HFLz semantics
%\newcommand {\val}[1]{[\![#1]\!]}
\newcommand {\val}[1]{ \llbracket #1 \rrbracket }
\newcommand {\vwt}[3][]{\val{\wt{#2}{#3}}(\alpha\ifthenelse{\isempty{#1}}{}{[#1]})}
\newcommand {\wta}[3]{\Gamma, #1 \vdash_H #2 : #3}
\newcommand {\vwta}[3]{\val{\wta{#1}{#2}{#3}}(\alpha)}
\newcommand {\Telem}[1]{ \top^{#1} } % top element of \domain{#1}
\newcommand {\Belem}[1]{ \bot^{#1} } % bot element of \domain{#1}

\newcommand {\valfun}{\alpha}
\newcommand {\domain}[1]{\mathcal{D}_{#1}}
\newcommand {\order}[1]{\sqsubseteq_{#1}}
\newcommand {\join}[1]{\sqcap_#1}
\newcommand {\meet}[1]{\sqcup_#1}
\newcommand {\tohfl}{\mathit{toHFL}}
% nu hflz operator
\newcommand {\fE} {\Gamma^f}
\newcommand {\clauses} {\mathcal{C}}
\newcommand {\system} {\mathcal{S}}
\newcommand {\fEo} {\sqsubseteq}
\newcommand {\hor}[1]{\sqcup_{#1}}

% simple type
\newcommand \stypeint {\textbf{Int}}
\newcommand \stypebool {\bullet}
\newcommand \stb {\stypebool}
\newcommand \sti {\stypeint}
\newcommand \srtype {\rho} % simple result type
\newcommand \st {\srtype} % simple result type
\newcommand \ty {\srtype}
\newcommand \satype {\eta} % simple argument type
\newcommand \senv {\Delta}
\newcommand \stE {\senv}
\newcommand \stypes {\vdash_H}
\newcommand \wt[3][]{\ifthenelse{\isempty{#1}}{\senv}{\senv, #1} \vdash_H #2: #3}

% refinement type syntax
\newcommand \constraint {\theta}
\newcommand \Cst {\constraint}
\newcommand \refty {\tau}
\newcommand \rty {\refty}
\newcommand \toprty {\pi}
\newcommand \typeint[1]{{#1} : \stypeint}
\newcommand \typebool[1]{\stypebool \langle #1 \rangle}
\newcommand \typeboolf[1]{\stypeboolf \langle #1 \rangle}
\newcommand \ti[1]{\typeint{#1}}
\newcommand \tb[1]{\typebool{#1}}
\newcommand \taus{\{\, \tau_1, \dots, \tau_n \,\}}
\newcommand \Bty[1]{\bot_{#1}}
\newcommand \Tty[1]{\top_{#1}}
\newcommand \wftypes {\vdash_W}

% refinement type judgement
\newcommand \refines[2]{#1:: #2}
\newcommand \tenv {\Gamma}
\newcommand \rtE {\tenv}
\newcommand \wf[2]{\tenv \vdash \refines{#1}{#2}}
\newcommand \minimalize[1] {#1_{\Downarrow}}
\newcommand \intE {\mathcal{I}}
\newcommand \TE[1] {\top_{#1}}
\newcommand \BE[1] {\bot_{#1}}

% refinement type semantics
%\newcommand {\semt}[1]{(\!|#1|\!)}
\newcommand {\semt}[1]{\llparenthesis \, #1 \, \rrparenthesis}
\newcommand {\mjudge}[2]{\tenv \models #1 \COL #2}
\newcommand {\semsbt}[3][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation #3}
\newcommand {\wsemsbt}[4][]{\tenv; \ifthenelse{\isempty{#1}}{\dcnstr}{#1} \models #2 \subtypeRelation_{#4} #3}
\newcommand {\srt}[2]{\semt{\wf{#1}{#2}}(\alpha)}
\newcommand {\srtg}[3][]{\semt{\wf{#2}{#3}}(\alpha[#1])}
\newcommand {\vc}[1]{[\!|#1|\!]}
\newcommand {\vtenv}[2][]{\val{#2}({\ifthenelse{\isempty{#1}}{\valfun}{#1}})}
%\newcommand {\semttaus}[1][] { \bigcap_i \semt{\tau_i}({\ifthenelse{\isempty{#1}}{\valfun}{#1}})}
\newcommand {\semttaus} {\bigcap_i \semt{\tau_i}(\valfun)}
\newcommand {\valrtE}[1] { \val{#1} }


% PDR rules
\newcommand {\rdecide} {\emph{Decide}}
\newcommand {\rconflict} {\emph{Conflict}}
\newcommand {\rvalid} {\emph{Valid}}
\newcommand {\rinit} {\emph{Init}}
\newcommand {\rinvalid} {\emph{Invalid}}
\newcommand {\rcandidate} {\emph{Candidate}}
\newcommand {\runfold} {\emph{Unfold}}
\newcommand {\rinitialize} {\emph{Initialize}}
\newcommand {\rinduction} {\emph{Induction}}
\newcommand {\runknown} {\emph{Unknown}}

\newcommand {\invalid} {\textbf{Invalid}}
\newcommand {\valid} {\textbf{Valid}}
\newcommand {\unknown} {\textbf{Unknown}}

\newcommand {\pdrmid} {\mathbin{||}}
\newcommand {\pdrapp} {\Longrightarrow }
\newcommand {\Tr} {\pdrapp}
\newcommand\config[2]{#1\pdrmid#2}
%\newcommand {\pdrtop} {\psi_{\mathcal{G}}}
\newcommand {\pdrtop} {\varphi}
\newcommand {\pdrtransform} {\mathcal{F}}
\newcommand {\pdrF} {\pdrtransform}
\newcommand {\floor}[1] {\lfloor #1 \rfloor }
\newcommand {\pdrtypes} {\uparrow}
\newcommand {\T} {\TE{\stE}}
\newcommand {\F} {\BE{\stE}}
\newcommand {\E} {\rtE}
\newcommand {\PT} {\pdrtop}
%\newcommand\pdrrule {\mathcal{R}}
\newcommand\RULES{\mathcal{R}}
\newcommand \breduc {\longrightarrow}


\newcommand {\tree} {\mathcal{T}}
\newcommand {\aprx} {\mathcal{A}}
\newcommand {\cex} {\mathcal{C}}

\newcommand {\treeroot} {\textbf{root}}

% negative types
\newcommand {\fenv} {\Delta} % negative type environment
\newcommand {\semtf}[1]{(\!|#1|\!)_\circ}
\newcommand {\srtf}[2]{\semtf{\wf{#1}{#2}}(\alpha)}

% conflict relation
\newcommand {\conflict}{\not \sim}
\newcommand {\consistent}{\sim}

\newcommand {\intersect} {\land}
\newcommand {\interpolation} {\textbf{Interp}}

% dual
\newcommand {\dual}[1]{\overline{#1}}

% non-idempotent intersection types
\newcommand \itypes {\vdash_I}
\newcommand \isBE {\mathit{isBaseEnv}} % isBaseEnv
\newcommand \sty {\mathit{sty}} % sty
\newcommand \iE {\tilde{\Delta}}
\newcommand \ity {\tilde{\srtype}}
\newcommand \tmpgen {\mathit{TempGen}}
\newcommand \newpred {\mathit{NewPred}}
\newcommand \ertE {\tilde{\rtE}}
\newcommand \erty {\tilde{\refty}}
\newcommand \econstr {\Theta}

% nu-hfl
\newcommand \lts {\mathcal{L}}
\newcommand \action {\mathcal{A}}
\newcommand \reduction {\longrightarrow}
\newcommand \stateq {q}
\newcommand \states {Q}
\newcommand \kotypes {\vdash}
\newcommand \msome[1] {\langle #1 \rangle}
\newcommand \mall[1] {[ #1 ]}

\newcommand \derivation {T}
%\newcommand \highlightcolor {red}

% Program
\lstdefinestyle{mystyle}{
 language=caml,
 basicstyle={\footnotesize\ttfamily},
 identifierstyle={\small},
commentstyle={\small\ttfamily \color[rgb]{0,0,0.5}},
keywordstyle={\small\bfseries \color[rgb]{0.8,0,0}},
keywordstyle = [2]{\color{orange}},
ndkeywordstyle={\small},
stringstyle={\small\ttfamily \color[rgb]{0,0,1}},
frame={tb},
breaklines=true,
columns=[l]{fullflexible},
%xrightmargin=0zw,
%xleftmargin=3zw,
numberstyle={\scriptsize},
stepnumber=1,
%numbersep=1zw,
morecomment=[l]{//},
morekeywords={assert}
}

% experiments
\newcommand \benchunno{{\it unno}}
\newcommand \benchmochiv{{\it mochi\_valid}}
\newcommand \benchmochiinv{{\it mochi\_invalid}}
\newcommand \benchmochi{{\it mochi}}

% misc
\newcommand{\figcaption}[1]{\def\@captype{figure}\caption{#1}}
\newcommand{\tblcaption}[1]{\def\@captype{table}\caption{#1}}
