use std::io::{self, Write};
use std::process::{Command, Stdio};

#[derive(Debug)]
pub enum Error {
    Preprocessor(String),
    UTFEncode,
    FailedToExecute(io::Error),
}

impl From<io::Error> for Error {
    fn from(e: io::Error) -> Self {
        Error::FailedToExecute(e)
    }
}

impl From<std::string::FromUtf8Error> for Error {
    fn from(_: std::string::FromUtf8Error) -> Self {
        Error::UTFEncode
    }
}

fn trim_white_space(s: &[u8]) -> &[u8] {
    for i in 0..s.len() {
        if !s[i].is_ascii_whitespace() {
            return &s[i..];
        }
    }
    return &s[s.len()..];
}

/// check if the given byte slice starts with "(check-sat"
///
/// This can detect check-sat and check-sat-assuming commands
fn starts_with_check_sat(s: &[u8]) -> bool {
    if !s.starts_with(b"(") {
        return false;
    }
    let s = &s[1..];
    let s = trim_white_space(s);
    s.starts_with(b"check-sat")
}

/// read until the next parenthensis at the same level.
///
/// This function understands the nesting of parenthses.
/// level: how many parentheses are opened but not closed
fn read_until_par(
    s: &[u8],
    idx: &mut usize,
    buf: &mut impl Write,
    mut level: usize,
) -> Result<(), Error> {
    for i in 0..s.len() {
        if s[i] == b'(' {
            level += 1;
        } else if s[i] == b')' {
            level -= 1;
            if level == 0 {
                buf.write_all(&s[..i + 1])?;
                *idx += i + 1;
                return Ok(());
            }
        }
    }
    Err(Error::Preprocessor("parenthesis not closed".to_string()))
}

/// fix top level clauses so that HoIce can handle them.
///
/// If the clause is (assert _), then it is converted to (assert (forall () _))
/// Otherwise, it dumps the clause as it is.
/// When handle_clause enconters (error ...), it raises an error immediately
fn handle_clause(data: &[u8], idx: &mut usize, buf: &mut impl Write) -> Result<(), Error> {
    let s = &data[*idx..];
    if s[0] != b'(' {
        return Ok(());
    }
    let s = &s[1..];
    let s = trim_white_space(s);

    if s.starts_with(b"error") {
        let mut error_data = Vec::new();
        error_data.write_all(b"(")?;
        read_until_par(s, idx, &mut error_data, 1)?;
        return Err(Error::Preprocessor(String::from_utf8(error_data)?));
    }

    if !s.starts_with(b"assert") {
        return read_until_par(&data[*idx..], idx, buf, 0);
    }
    let s = &s[6..];
    let s = trim_white_space(s);
    if s[0] == b'(' {
        let s = &s[1..];
        let s = trim_white_space(s);
        if s.starts_with(b"forall") {
            return read_until_par(&data[*idx..], idx, buf, 0);
        }
    }

    buf.write_all(b"(assert (forall () ")?;
    // move the current position to the end of "(assert ";
    *idx += data[*idx..].len() - s.len();
    read_until_par(s, idx, buf, 1)?;
    buf.write_all(b")")?;

    Ok(())
}

#[test]
fn test_handle_clause() {
    let mut buf = Vec::new();
    let data = b"(assert (forall ((x Int)) (=> (p x) (q x))))";
    let mut idx = 0;
    handle_clause(data, &mut idx, &mut buf).unwrap();
    println!("result: {}", std::str::from_utf8(&buf).unwrap());
    assert_eq!(buf, data);
    assert_eq!(idx, data.len());

    let mut buf = Vec::new();
    let data = b"(assert false)";
    let mut idx = 0;
    handle_clause(data, &mut idx, &mut buf).unwrap();
    println!("result: {}", std::str::from_utf8(&buf).unwrap());
    assert_eq!(buf, b"(assert (forall () false))");
    assert_eq!(idx, data.len());

    let mut buf = Vec::new();
    let data = b"(error \"error message\")";
    let mut idx = 0;
    assert!(handle_clause(data, &mut idx, &mut buf).is_err())
}

/// reads until it encounters "(check-sat" and writes the content to the given buffer
/// then returns Ok(s) where s is the continuation of the clauses
/// such as "(check-sat)\n(exit)" if succeeds
fn inputs_smt2_to_z3(filename: &str, mut buf: impl Write) -> Result<(), Error> {
    let data = std::fs::read(filename).unwrap();
    let mut idx = 0;
    let len = data.len();
    while idx < len {
        if data[idx] == b';' {
            while idx < len && data[idx] != b'\n' {
                idx += 1;
            }
        } else if starts_with_check_sat(&data[idx..]) {
            buf.write_all(&data[..idx])?;
            buf.write_all(b"\n(apply (then horn-simplify) :print false :print-benchmark true)")?;
            buf.write_all(b"\n(exit)")?;
            return Ok(());
        }
        idx += 1
    }
    Err(Error::Preprocessor("check-sat not found".to_string()))
}

/// Postprocess the smt2 generated by z3 for HoIce
fn postprocess_smt2_for_hoice(data: &[u8]) -> Result<String, Error> {
    let mut buf = Vec::new();
    // header
    buf.write_all(b"(set-logic HORN)\n")?;

    // processing the content
    let mut idx = 0;
    let len = data.len();
    while idx < len {
        if data[idx] == b';' {
            while idx < len && data[idx] != b'\n' {
                idx += 1;
            }
        } else if data[idx..].starts_with(b"(") {
            handle_clause(&data, &mut idx, &mut buf)?;
        } else {
            buf.write_all(&data[idx..idx + 1])?;
            idx += 1;
        }
    }
    Ok(String::from_utf8(buf)?)
}

/// Preprocess the given file and returns the HFLz formula string
///
/// Before open `filename`, `open_file_with_preprocess` executes command `hfl-preprocessor` (github.com/moratorium08/hfl-preprocessor`,
/// which transforms hfls with some heuristics without changing the validity (inlining, removing disjunctions, etc)
/// These functionalities should be implemented in hopdr in the future.
pub fn open_file_with_preprocess(filename: &str) -> Result<String, Error> {
    

    crate::stat::preprocess::start_clock("spacer-preprocessor");

    const CMD: &str = "z3";

    let args = vec!["-in"];
    let mut child = Command::new(CMD)
        .args(args)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;
    let child_stdin = child.stdin.as_mut().unwrap();

    inputs_smt2_to_z3(filename, child_stdin)?;

    let output = child.wait_with_output()?;
    let s = &output.stdout;
    crate::stat::preprocess::end_clock("spacer-preprocessor");

    postprocess_smt2_for_hoice(s)
}

#[test]
fn test_spacer_preprocessor() {
    use tempfile::NamedTempFile;
    let chc_data = [
        "
    (set-logic HORN)
(declare-fun mc91 ( Int Int ) Bool)
(assert (forall ((n Int)) (=> (> n 100) (mc91 n (- n 10)))))
(assert (forall ((n Int) (t Int) (r Int))
    (=>
        (and
            (<= n 100)
            (mc91 (+ n 11) t)
            (mc91 t r)
        )
        (mc91 n r)
    )
))
(assert (forall ((n Int) (r Int))
    (=>
        (and
            (<= n 101)
            (not (= r 91))
            (mc91 n r)
        )
        false
    )
))
(check-sat)
    ",
        "(set-logic HORN)
(declare-fun inv (Int Int) Bool)
(assert (inv 0 1))
(assert (forall ((A Int) (B Int) (C Int) (D Int))
          (! (let ((a!1 (ite (and (not (<= B (- 100))) (not (<= 100 B)))
                             C
                             (* (- 1) C))))
               (=> (and (inv D C) (= A a!1) (= B (+ D C))) (inv B A)))
             :weight 0)))
(assert (forall ((A Int) (B Int))
          (! (=> (and (inv A B) (<= A 100) (>= A (- 100))) false) :weight 0)))
(check-sat)",
    ];
    for s in chc_data.iter() {
        println!("before preprocessing: \n{}", s);
        let mut tf = NamedTempFile::new().unwrap();
        tf.write_all(s.as_bytes()).unwrap();

        let s = open_file_with_preprocess(tf.path().to_str().unwrap()).unwrap();
        println!("after preprocessing: \n{}", s);
        assert!(s.starts_with("(set-logic HORN)"));
    }
}
